<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rappel DAG Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #0a0a0a;
            color: #e4e4e7;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(to right, #18181b, #27272a);
            border-bottom: 1px solid #3f3f46;
            padding: 16px 24px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 600;
            color: #fff;
        }

        .header .badge {
            background: #3b82f6;
            color: white;
            padding: 4px 10px;
            border-radius: 9999px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr 1.5fr;
            gap: 1px;
            background: #27272a;
            height: calc(100vh - 57px);
        }

        .panel {
            background: #0a0a0a;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            padding: 12px 16px;
            background: #18181b;
            border-bottom: 1px solid #27272a;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-header .icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .panel-header h2 {
            font-size: 14px;
            font-weight: 600;
            color: #a1a1aa;
        }

        .panel-content {
            flex: 1;
            overflow: auto;
            padding: 16px;
        }

        pre {
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 12px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #d4d4d8;
        }

        .dag-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .dag-svg {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .dag-nodes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .dag-node {
            position: absolute;
            background: #18181b;
            border: 2px solid #3f3f46;
            border-radius: 12px;
            padding: 10px 14px;
            cursor: pointer;
            transition: all 0.15s ease;
            min-width: 140px;
            max-width: 200px;
        }

        .dag-node:hover {
            border-color: #6366f1;
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.2);
        }

        .dag-node.selected {
            border-color: #22c55e;
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.3);
        }

        .dag-node .node-id {
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            color: #71717a;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 4px;
        }

        .dag-node .node-label {
            font-size: 12px;
            font-weight: 500;
            color: #e4e4e7;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .dag-node .node-type {
            font-size: 10px;
            color: #a1a1aa;
            margin-top: 4px;
        }

        /* Node type colors */
        .dag-node[data-type="input"] {
            border-color: #22c55e;
            background: linear-gradient(135deg, #14532d 0%, #18181b 100%);
        }

        .dag-node[data-type="output"] {
            border-color: #f97316;
            background: linear-gradient(135deg, #7c2d12 0%, #18181b 100%);
        }

        .dag-node[data-type="action_call"] {
            border-color: #3b82f6;
            background: linear-gradient(135deg, #1e3a5f 0%, #18181b 100%);
        }

        .dag-node[data-type="assignment"] {
            border-color: #8b5cf6;
            background: linear-gradient(135deg, #4c1d95 0%, #18181b 100%);
        }

        .dag-node[data-type="for_loop"] {
            border-color: #06b6d4;
            background: linear-gradient(135deg, #164e63 0%, #18181b 100%);
        }

        .dag-node[data-type="if"] {
            border-color: #eab308;
            background: linear-gradient(135deg, #713f12 0%, #18181b 100%);
        }

        .dag-node[data-type="branch"] {
            border-color: #eab308;
            background: linear-gradient(135deg, #713f12 0%, #18181b 100%);
        }

        .dag-node[data-type="spread_action"] {
            border-color: #ec4899;
            background: linear-gradient(135deg, #831843 0%, #18181b 100%);
        }

        .dag-node[data-type="aggregator"] {
            border-color: #10b981;
            background: linear-gradient(135deg, #064e3b 0%, #18181b 100%);
        }

        .dag-node[data-type="join"] {
            border-color: #6366f1;
            background: linear-gradient(135deg, #312e81 0%, #18181b 100%);
        }

        .edge-control {
            stroke: #4b5563;
            stroke-width: 2;
            fill: none;
            marker-end: url(#arrowhead);
        }

        .edge-data {
            stroke: #a855f7;
            stroke-width: 2;
            stroke-dasharray: 6, 4;
            fill: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            marker-end: url(#arrowhead-data);
        }

        .edge-data.visible {
            opacity: 1;
        }

        .edge-label {
            font-family: 'SF Mono', monospace;
            font-size: 10px;
            fill: #c084fc;
            font-weight: 500;
            transition: opacity 0.2s ease;
        }

        .edge-label.visible {
            opacity: 1 !important;
        }

        .edge-loop-back {
            stroke: #06b6d4;
            stroke-width: 2;
            stroke-dasharray: 8, 4;
        }

        .legend {
            position: absolute;
            bottom: 16px;
            left: 16px;
            background: #18181b;
            border: 1px solid #27272a;
            border-radius: 8px;
            padding: 12px;
            font-size: 11px;
            z-index: 100;
        }

        .legend-title {
            font-weight: 600;
            color: #a1a1aa;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
        }

        .legend-color {
            width: 24px;
            height: 4px;
            border-radius: 2px;
        }

        .legend-color.control {
            background: #4b5563;
        }

        .legend-color.data {
            background: #a855f7;
            background: repeating-linear-gradient(
                90deg,
                #a855f7,
                #a855f7 6px,
                transparent 6px,
                transparent 10px
            );
        }

        .legend-color.loop-back {
            background: #06b6d4;
            background: repeating-linear-gradient(
                90deg,
                #06b6d4,
                #06b6d4 8px,
                transparent 8px,
                transparent 12px
            );
        }

        .help-text {
            position: absolute;
            top: 16px;
            right: 16px;
            background: #18181b;
            border: 1px solid #27272a;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 11px;
            color: #71717a;
            z-index: 100;
        }

        /* Node type legend */
        .node-legend {
            position: absolute;
            bottom: 16px;
            right: 16px;
            background: #18181b;
            border: 1px solid #27272a;
            border-radius: 8px;
            padding: 12px;
            font-size: 11px;
            z-index: 100;
        }

        .node-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
        }

        .node-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 4px;
            border: 2px solid;
        }

        .node-legend-color.input { border-color: #22c55e; background: #14532d; }
        .node-legend-color.output { border-color: #f97316; background: #7c2d12; }
        .node-legend-color.action { border-color: #3b82f6; background: #1e3a5f; }
        .node-legend-color.assignment { border-color: #8b5cf6; background: #4c1d95; }
        .node-legend-color.for-loop { border-color: #06b6d4; background: #164e63; }
        .node-legend-color.branch { border-color: #eab308; background: #713f12; }
        .node-legend-color.spread { border-color: #ec4899; background: #831843; }
        .node-legend-color.join { border-color: #6366f1; background: #312e81; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Rappel DAG Visualizer</h1>
        <span class="badge">Interactive</span>
    </div>

    <div class="container">
        <div class="panel">
            <div class="panel-header">
                <div class="icon">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#fbbf24" stroke-width="2">
                        <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                    </svg>
                </div>
                <h2>Python Source</h2>
            </div>
            <div class="panel-content">
                <pre id="python-source"></pre>
            </div>
        </div>

        <div class="panel">
            <div class="panel-header">
                <div class="icon">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#a78bfa" stroke-width="2">
                        <rect x="3" y="3" width="18" height="18" rx="2"/>
                        <path d="M9 9h6M9 12h6M9 15h4"/>
                    </svg>
                </div>
                <h2>Intermediate Representation (IR)</h2>
            </div>
            <div class="panel-content">
                <pre id="ir-text"></pre>
            </div>
        </div>

        <div class="panel">
            <div class="panel-header">
                <div class="icon">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#34d399" stroke-width="2">
                        <circle cx="12" cy="5" r="3"/>
                        <circle cx="5" cy="19" r="3"/>
                        <circle cx="19" cy="19" r="3"/>
                        <path d="M12 8v4M9 16l-2.5-4M15 16l2.5-4"/>
                    </svg>
                </div>
                <h2>Execution DAG</h2>
            </div>
            <div class="panel-content">
                <div class="dag-container" id="dag-container">
                    <svg class="dag-svg" id="dag-svg">
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#4b5563"/>
                            </marker>
                            <marker id="arrowhead-data" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#a855f7"/>
                            </marker>
                        </defs>
                    </svg>
                    <div class="dag-nodes" id="dag-nodes"></div>

                    <div class="legend">
                        <div class="legend-title">Edge Types</div>
                        <div class="legend-item">
                            <div class="legend-color control"></div>
                            <span>Control Flow</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color data"></div>
                            <span>Data Flow (click node)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color loop-back"></div>
                            <span>Loop Back</span>
                        </div>
                    </div>

                    <div class="help-text">
                        Click a node to see data flow edges
                    </div>

                    <div class="node-legend">
                        <div class="legend-title">Node Types</div>
                        <div class="node-legend-item">
                            <div class="node-legend-color input"></div>
                            <span>Input/Output</span>
                        </div>
                        <div class="node-legend-item">
                            <div class="node-legend-color action"></div>
                            <span>Action Call</span>
                        </div>
                        <div class="node-legend-item">
                            <div class="node-legend-color assignment"></div>
                            <span>Assignment</span>
                        </div>
                        <div class="node-legend-item">
                            <div class="node-legend-color for-loop"></div>
                            <span>For Loop</span>
                        </div>
                        <div class="node-legend-item">
                            <div class="node-legend-color branch"></div>
                            <span>Branch</span>
                        </div>
                        <div class="node-legend-item">
                            <div class="node-legend-color spread"></div>
                            <span>Parallel/Spread</span>
                        </div>
                        <div class="node-legend-item">
                            <div class="node-legend-color join"></div>
                            <span>Join</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const data = __JSON_DATA__;

        // Display Python source
        document.getElementById('python-source').textContent = data.python_source;

        // Display IR text
        document.getElementById('ir-text').textContent = data.ir_text;

        // Build DAG visualization
        const container = document.getElementById('dag-container');
        const svg = document.getElementById('dag-svg');
        const nodesContainer = document.getElementById('dag-nodes');

        const nodes = data.dag.nodes;
        const edges = data.dag.edges;

        // Build adjacency info
        const nodeMap = new Map(nodes.map(n => [n.id, n]));
        const incomingEdges = new Map();
        const outgoingEdges = new Map();

        edges.forEach(edge => {
            if (!incomingEdges.has(edge.target)) incomingEdges.set(edge.target, []);
            if (!outgoingEdges.has(edge.source)) outgoingEdges.set(edge.source, []);
            incomingEdges.get(edge.target).push(edge);
            outgoingEdges.get(edge.source).push(edge);
        });

        // Compute topological depth
        const depthCache = new Map();
        function computeDepth(nodeId, visited = new Set()) {
            if (depthCache.has(nodeId)) return depthCache.get(nodeId);
            if (visited.has(nodeId)) return 0;
            visited.add(nodeId);

            const incoming = (incomingEdges.get(nodeId) || [])
                .filter(e => e.edge_type === 'control_flow' && !e.is_loop_back);

            let maxDepth = 0;
            incoming.forEach(edge => {
                maxDepth = Math.max(maxDepth, computeDepth(edge.source, visited) + 1);
            });

            depthCache.set(nodeId, maxDepth);
            return maxDepth;
        }

        nodes.forEach(n => computeDepth(n.id));

        // Group by depth
        const levels = [];
        nodes.forEach(node => {
            const depth = depthCache.get(node.id) || 0;
            if (!levels[depth]) levels[depth] = [];
            levels[depth].push(node);
        });

        // Layout parameters
        const padding = 40;
        const topPadding = 150;  // Extra space at top for data flow arcs
        const columnGap = 260;
        const rowGap = 100;
        const nodeWidth = 180;
        const nodeHeight = 70;

        // Position nodes
        const positions = new Map();
        let maxX = 0;
        let maxY = 0;

        levels.forEach((levelNodes, depth) => {
            levelNodes.forEach((node, index) => {
                const x = padding + depth * columnGap;
                const y = topPadding + index * rowGap;
                positions.set(node.id, { x, y, cx: x + nodeWidth / 2, cy: y + nodeHeight / 2 });
                maxX = Math.max(maxX, x + nodeWidth);
                maxY = Math.max(maxY, y + nodeHeight);
            });
        });

        // Set SVG size (extra space at top for data flow arcs)
        svg.setAttribute('width', maxX + padding);
        svg.setAttribute('height', maxY + padding);
        container.style.minWidth = (maxX + padding) + 'px';
        container.style.minHeight = (maxY + padding) + 'px';

        // Draw edges
        const edgeElements = new Map();

        // Track data flow edge indices for vertical offset
        const dataFlowIndex = new Map();

        edges.forEach((edge, idx) => {
            const start = positions.get(edge.source);
            const end = positions.get(edge.target);
            if (!start || !end) return;

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const isDataFlow = edge.edge_type === 'data_flow';

            // Calculate path
            let d;
            if (isDataFlow) {
                // Data flow edges: arc ABOVE the graph with variable heights
                const edgeKey = `${edge.source}->${edge.target}`;
                let offsetIdx = dataFlowIndex.get(edge.target) || 0;
                dataFlowIndex.set(edge.target, offsetIdx + 1);

                // Calculate arc height based on horizontal distance and index
                const dx = Math.abs(end.cx - start.cx);
                const baseArcHeight = Math.max(80, dx * 0.3);
                const arcHeight = baseArcHeight + (offsetIdx * 25);

                // Start from top of source node, end at top of target node
                const startX = start.cx;
                const startY = start.y - 5;
                const endX = end.cx;
                const endY = end.y - 5;

                // Control point for the arc (above both nodes)
                const midX = (startX + endX) / 2;
                const midY = Math.min(startY, endY) - arcHeight;

                d = `M${startX},${startY} Q${midX},${midY} ${endX},${endY}`;
            } else if (edge.is_loop_back) {
                // Loop back: curve around below
                const midY = Math.max(start.cy, end.cy) + 60;
                d = `M${start.cx + nodeWidth/2},${start.cy}
                     Q${start.cx + nodeWidth/2 + 40},${midY} ${end.cx},${end.cy + nodeHeight/2}`;
            } else if (start.x > end.x) {
                // Backward control flow edge
                const midY = Math.min(start.cy, end.cy) - 50;
                d = `M${start.cx - nodeWidth/2},${start.cy}
                     Q${(start.cx + end.cx)/2},${midY} ${end.cx + nodeWidth/2},${end.cy}`;
            } else {
                // Forward control flow edge
                const dx = end.cx - start.cx;
                d = `M${start.cx + nodeWidth/2},${start.cy}
                     C${start.cx + nodeWidth/2 + dx/3},${start.cy}
                      ${end.cx - nodeWidth/2 - dx/3},${end.cy}
                      ${end.cx - nodeWidth/2},${end.cy}`;
            }

            path.setAttribute('d', d);

            if (isDataFlow) {
                path.classList.add('edge-data');
                path.dataset.target = edge.target;
                path.dataset.source = edge.source;
                if (edge.variable) {
                    path.dataset.variable = edge.variable;
                }

                // Add variable label on the arc
                if (edge.variable) {
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    const offsetIdx = (dataFlowIndex.get(edge.target) || 1) - 1;
                    const dx = Math.abs(end.cx - start.cx);
                    const baseArcHeight = Math.max(80, dx * 0.3);
                    const arcHeight = baseArcHeight + (offsetIdx * 25);
                    const midX = (start.cx + end.cx) / 2;
                    const midY = Math.min(start.y, end.y) - arcHeight - 5;

                    label.setAttribute('x', midX);
                    label.setAttribute('y', midY);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('class', 'edge-label');
                    label.textContent = edge.variable;
                    label.style.opacity = '0';
                    label.dataset.target = edge.target;
                    svg.appendChild(label);

                    if (!edgeElements.has(edge.target)) edgeElements.set(edge.target, []);
                    edgeElements.get(edge.target).push(label);
                }
            } else {
                path.classList.add('edge-control');
                if (edge.is_loop_back) {
                    path.classList.add('edge-loop-back');
                }
            }

            svg.appendChild(path);

            if (isDataFlow) {
                if (!edgeElements.has(edge.target)) edgeElements.set(edge.target, []);
                edgeElements.get(edge.target).push(path);
            }
        });

        // Create node elements
        let selectedNode = null;

        nodes.forEach(node => {
            const pos = positions.get(node.id);
            if (!pos) return;

            const el = document.createElement('div');
            el.className = 'dag-node';

            // Determine node type for styling
            let dataType = node.node_type;
            if (node.is_input) dataType = 'input';
            else if (node.is_output) dataType = 'output';
            else if (node.is_aggregator) dataType = 'aggregator';
            else if (node.is_spread) dataType = 'spread_action';
            else if (node.node_type === 'branch' || node.node_type === 'if') dataType = 'branch';
            else if (node.node_type === 'join') dataType = 'join';

            el.dataset.type = dataType;
            el.style.left = pos.x + 'px';
            el.style.top = pos.y + 'px';
            el.style.width = nodeWidth + 'px';

            // Build label
            let label = node.label;
            if (node.action_name) {
                label = '@' + node.action_name;
            } else if (label.length > 25) {
                label = label.substring(0, 22) + '...';
            }

            el.innerHTML = `
                <div class="node-id">${node.id}</div>
                <div class="node-label">${label}</div>
                <div class="node-type">${node.node_type}${node.targets ? ' -> ' + node.targets.join(', ') : ''}</div>
            `;

            // Click handler to show data flow edges
            el.addEventListener('click', () => {
                // Deselect previous
                if (selectedNode) {
                    selectedNode.classList.remove('selected');
                    const prevEdges = edgeElements.get(selectedNode.dataset.nodeId) || [];
                    prevEdges.forEach(e => e.classList.remove('visible'));
                }

                // Toggle selection
                if (selectedNode === el) {
                    selectedNode = null;
                } else {
                    selectedNode = el;
                    el.classList.add('selected');
                    el.dataset.nodeId = node.id;

                    // Show incoming data edges
                    const nodeEdges = edgeElements.get(node.id) || [];
                    nodeEdges.forEach(e => e.classList.add('visible'));
                }
            });

            el.dataset.nodeId = node.id;
            nodesContainer.appendChild(el);
        });

        // Click outside to deselect
        container.addEventListener('click', (e) => {
            if (e.target === container || e.target === nodesContainer) {
                if (selectedNode) {
                    selectedNode.classList.remove('selected');
                    const prevEdges = edgeElements.get(selectedNode.dataset.nodeId) || [];
                    prevEdges.forEach(e => e.classList.remove('visible'));
                    selectedNode = null;
                }
            }
        });
    </script>
</body>
</html>
