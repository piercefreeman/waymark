syntax = "proto3";

package rappel.execution;

// =============================================================================
// Execution Graph
// =============================================================================
// The execution graph is the single source of truth for workflow instance state.
// It contains all nodes (pending, running, completed), their results, and
// variable bindings. This replaces the separate action_queue, node_inputs,
// node_readiness, and instance_context tables.

// Complete execution state for a workflow instance
message ExecutionGraph {
  // All nodes in the execution (keyed by node_id, e.g., "action_1" or "spread_1[0]")
  map<string, ExecutionNode> nodes = 1;

  // Variable bindings (name -> serialized value as bytes)
  map<string, bytes> variables = 2;

  // Node IDs ready to be dispatched to workers
  repeated string ready_queue = 3;

  // Exceptions that have been raised (for try/except handling)
  map<string, ExceptionInfo> exceptions = 4;

  // Next wake-up time (epoch ms) when all active paths are sleeping.
  // Only set when no immediate work is available.
  optional int64 next_wakeup_time = 5;
}

// State of a single node in the execution graph
message ExecutionNode {
  // Reference to template node in the DAG
  string template_id = 1;

  // For spread-expanded nodes: which index in the spread (0, 1, 2, ...)
  optional int32 spread_index = 2;

  // Current status
  NodeStatus status = 3;

  // Worker assignment (when status = RUNNING)
  optional string worker_id = 4;
  optional int64 started_at_ms = 5;

  // Unique identifier for this specific execution instance.
  // Generated when the action starts running (mark_running).
  // Used as the key for payload storage and retrieval.
  optional string execution_id = 26;

  // Completion info (when status = COMPLETED or FAILED)
  optional int64 completed_at_ms = 6;
  optional int64 duration_ms = 7;

  // I/O captured for logging/debugging
  optional bytes inputs = 8;   // Serialized kwargs sent to action
  optional bytes result = 9;   // Serialized return value
  optional string error = 10;  // Error message if failed
  optional string error_type = 11; // Exception type if failed

  // For barriers/joins: which nodes we're waiting for
  repeated string waiting_for = 12;
  int32 completed_count = 13;

  // Retry tracking
  int32 attempt_number = 14;
  int32 max_retries = 15;
  repeated AttemptRecord attempts = 16;

  // Execution policies (copied from DAG node)
  int32 timeout_seconds = 17;
  int32 timeout_retry_limit = 18;
  BackoffConfig backoff = 19;

  // For loop nodes: current iteration state
  optional int32 loop_index = 20;
  optional bytes loop_accumulators = 21;

  // Target variable(s) to store result
  repeated string targets = 22;

  // Explicit node type - the source of truth
  NodeKind node_kind = 23;

  // Parent node that spawned this (for spread children, loop iterations)
  // Set when this node is dynamically created from a template
  optional string parent_execution_id = 24;

  // For archived loop iterations: which iteration (0, 1, 2, ...)
  // Set when a node is archived during loop reset
  optional int32 iteration_index = 25;
}

// Record of a single execution attempt (for retry history)
message AttemptRecord {
  int32 attempt_number = 1;
  string worker_id = 2;
  int64 started_at_ms = 3;
  int64 completed_at_ms = 4;
  int64 duration_ms = 5;
  bool success = 6;
  optional bytes result = 7;
  optional string error = 8;
  optional string error_type = 9;
}

// Node execution status
enum NodeStatus {
  NODE_STATUS_UNSPECIFIED = 0;
  NODE_STATUS_BLOCKED = 1;    // Waiting for predecessors
  NODE_STATUS_PENDING = 2;    // Ready to run, in ready_queue
  NODE_STATUS_RUNNING = 3;    // Dispatched to worker
  NODE_STATUS_COMPLETED = 4;  // Finished successfully
  NODE_STATUS_FAILED = 5;     // Finished with error (terminal)
  NODE_STATUS_EXHAUSTED = 6;  // Exceeded retry limit (terminal)
  NODE_STATUS_CAUGHT = 7;     // Exception caught by handler (terminal)
}

// Explicit node type - no more string matching or DAG lookups
enum NodeKind {
  NODE_KIND_UNSPECIFIED = 0;
  NODE_KIND_ACTION = 1;      // Regular action call
  NODE_KIND_SLEEP = 2;       // Sleep action (special handling)
  NODE_KIND_ASSIGNMENT = 3;  // Variable assignment
  NODE_KIND_BRANCH = 4;      // Conditional branch
  NODE_KIND_JOIN = 5;        // Join point for branches
  NODE_KIND_AGGREGATOR = 6;  // Collects spread results
  NODE_KIND_FN_CALL = 7;     // Function call
  NODE_KIND_RETURN = 8;      // Return statement
  NODE_KIND_BREAK = 9;       // Loop break
  NODE_KIND_FOR_LOOP = 10;   // For loop controller
  NODE_KIND_INPUT = 11;      // Function input boundary
  NODE_KIND_OUTPUT = 12;     // Function output boundary
  NODE_KIND_SPREAD = 13;     // Spread expansion template
}

// Backoff configuration for retries
message BackoffConfig {
  BackoffKind kind = 1;
  int32 base_delay_ms = 2;
  double multiplier = 3;
}

enum BackoffKind {
  BACKOFF_KIND_UNSPECIFIED = 0;
  BACKOFF_KIND_NONE = 1;
  BACKOFF_KIND_LINEAR = 2;
  BACKOFF_KIND_EXPONENTIAL = 3;
}

// Exception information for error handling
message ExceptionInfo {
  string error_type = 1;
  string error_module = 2;
  string error_message = 3;
  string traceback = 4;
  // Exception class hierarchy for except matching
  repeated string type_hierarchy = 5;
  // Node that raised the exception
  string source_node_id = 6;
}
