{% extends "base.html" %}
{% import "macros.html" as macros %}

{% block title %}{{ title }}{% endblock title %}

{% block content %}
<section class="space-y-4">
    <a href="/workflows/{{ workflow.id }}" class="inline-flex items-center gap-1.5 text-xs uppercase tracking-[0.3em] text-zinc-500 transition hover:text-zinc-700 dark:hover:text-zinc-300">
        <svg class="h-3.5 w-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
        </svg>
        Back to workflow detail
    </a>
    <div class="flex items-start justify-between gap-4">
        <div class="space-y-2">
            <h1 class="text-3xl font-semibold tracking-tight text-zinc-900 dark:text-white">Run {{ instance.id }}</h1>
            <p class="text-sm text-zinc-600 dark:text-zinc-400">{{ workflow.name }}</p>
        </div>
        <button id="export-btn" onclick="exportInstance()" class="inline-flex items-center gap-2 rounded-lg border border-zinc-300 dark:border-zinc-700 bg-white dark:bg-zinc-900 px-4 py-2 text-sm font-medium text-zinc-700 dark:text-zinc-300 shadow-sm hover:bg-zinc-50 dark:hover:bg-zinc-800 transition-colors">
            <svg class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
            </svg>
            Export JSON
        </button>
    </div>
    <dl class="grid gap-6 rounded-xl border border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-950 p-6 md:grid-cols-2 lg:grid-cols-3">
        <div class="space-y-1">
            <dt class="text-xs uppercase tracking-[0.3em] text-zinc-500">Version ID</dt>
            <dd class="font-mono text-sm text-zinc-800 dark:text-zinc-200">{{ workflow.id }}</dd>
        </div>
        <div class="space-y-1">
            <dt class="text-xs uppercase tracking-[0.3em] text-zinc-500">Run Created</dt>
            <dd class="text-sm font-medium text-zinc-800 dark:text-zinc-200">{{ macros::datetime(timestamp=instance.created_at) }}</dd>
        </div>
        <div class="space-y-1">
            <dt class="text-xs uppercase tracking-[0.3em] text-zinc-500">Status</dt>
            <dd class="text-sm font-medium text-zinc-800 dark:text-zinc-200">{{ instance.status }}</dd>
        </div>
    </dl>
</section>

<section class="grid gap-6 lg:grid-cols-2">
    <div class="rounded-xl border border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-950 p-5">
        <p class="text-xs uppercase tracking-[0.3em] text-zinc-500 mb-3">Input Payload</p>
        <pre class="overflow-x-auto whitespace-pre-wrap rounded-lg border border-zinc-200 dark:border-zinc-800 bg-zinc-50 dark:bg-zinc-900 p-4 font-mono text-xs text-zinc-700 dark:text-zinc-300">{{ instance.input_payload }}</pre>
    </div>
    <div class="rounded-xl border border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-950 p-5">
        <p class="text-xs uppercase tracking-[0.3em] text-zinc-500 mb-3">Result Payload</p>
        <pre class="max-h-64 overflow-auto whitespace-pre-wrap rounded-lg border border-zinc-200 dark:border-zinc-800 bg-zinc-50 dark:bg-zinc-900 p-4 font-mono text-xs text-zinc-700 dark:text-zinc-300">{{ instance.result_payload }}</pre>
    </div>
</section>

<section class="space-y-3">
    <div>
        <p class="text-xs uppercase tracking-[0.3em] text-zinc-500">DAG</p>
        <h2 class="text-2xl font-semibold text-zinc-900 dark:text-white">Execution Graph</h2>
        <p class="text-sm text-zinc-500 dark:text-zinc-500">Workflow dependency structure</p>
    </div>
    <!-- Horizontal DAG -->
    <div id="execution-graph" class="relative min-h-[300px] max-h-[500px] overflow-auto rounded-xl border border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-950 bg-grid p-4">
        <p id="graph-empty" class="p-6 text-sm text-zinc-500 dark:text-zinc-500">No DAG nodes to display.</p>
    </div>
</section>

<!-- Gantt-style Timeline -->
<section class="space-y-3">
    <div>
        <p class="text-xs uppercase tracking-[0.3em] text-zinc-500">Timeline</p>
        <h2 class="text-2xl font-semibold text-zinc-900 dark:text-white">Execution Timeline</h2>
        <p class="text-sm text-zinc-500 dark:text-zinc-500">Action execution timing and duration</p>
    </div>
    <div id="timeline-container" class="rounded-xl border border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-950 overflow-hidden">
        <div id="timeline-empty" class="text-center py-8 text-zinc-500 dark:text-zinc-500">
            <p class="text-sm">No execution logs recorded yet</p>
        </div>
        <div id="timeline-gantt" class="hidden">
            <!-- Gantt chart will be rendered here -->
        </div>
    </div>
</section>

<!-- Execution Log (list-based view) -->
<section class="space-y-3">
    <div>
        <p class="text-xs uppercase tracking-[0.3em] text-zinc-500">Log</p>
        <h2 class="text-2xl font-semibold text-zinc-900 dark:text-white">Execution Log</h2>
        <p class="text-sm text-zinc-500 dark:text-zinc-500">Chronological history of all action executions</p>
    </div>
    <div id="log-container" class="rounded-xl border border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-950 overflow-hidden">
        <div id="log-empty" class="text-center py-8 text-zinc-500 dark:text-zinc-500">
            <p class="text-sm">No execution logs recorded yet</p>
        </div>
        <div id="log-content" class="hidden divide-y divide-zinc-100 dark:divide-zinc-800/50">
            <!-- Log entries will be injected here -->
        </div>
        <div id="log-load-more-container" class="hidden py-4 text-center border-t border-zinc-200 dark:border-zinc-800">
            <button id="log-load-more" class="rounded-lg border border-zinc-300 dark:border-zinc-700 px-4 py-2 text-xs font-medium text-zinc-600 dark:text-zinc-400 hover:bg-zinc-100 dark:hover:bg-zinc-800 transition-colors">
                Load more
            </button>
        </div>
    </div>
</section>

<!-- Sliding Detail Panel -->
<div id="detail-drawer" class="fixed inset-y-0 right-0 z-50 w-full max-w-md transform translate-x-full transition-transform duration-300 ease-in-out" style="margin: 16px; margin-right: 0; height: calc(100% - 32px);">
    <div class="h-full flex flex-col bg-white/80 dark:bg-zinc-900/80 backdrop-blur-3xl border border-white/30 dark:border-zinc-700/50 rounded-l-2xl shadow-[0_0_60px_-15px_rgba(0,0,0,0.3)] dark:shadow-[0_0_60px_-15px_rgba(0,0,0,0.5)]">
        <!-- Header -->
        <div class="flex items-center justify-between p-5 border-b border-zinc-200/30 dark:border-zinc-700/30 rounded-tl-2xl">
            <div class="min-w-0 flex-1">
                <p id="drawer-title" class="text-xl font-semibold text-zinc-900 dark:text-white truncate"></p>
                <p id="drawer-subtitle" class="text-sm text-zinc-500 truncate mt-0.5 font-mono"></p>
            </div>
            <button id="drawer-close" class="ml-4 p-2 rounded-xl text-zinc-400 hover:text-zinc-600 dark:hover:text-white hover:bg-white/50 dark:hover:bg-zinc-700/50 transition-colors">
                <svg class="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
        <!-- Content -->
        <div id="drawer-content" class="flex-1 overflow-auto p-5 space-y-5">
            <!-- Status and duration -->
            <div class="flex items-center gap-3">
                <span id="drawer-status" class="rounded-lg px-2.5 py-1 text-xs font-semibold uppercase tracking-wide"></span>
                <span id="drawer-duration" class="text-sm text-zinc-500"></span>
            </div>
            <!-- Timing info -->
            <div class="rounded-xl border border-white/20 dark:border-zinc-700/50 bg-white/40 dark:bg-zinc-800/40 p-4">
                <div class="grid grid-cols-2 gap-4 text-sm">
                    <div>
                        <span class="text-xs uppercase tracking-wider text-zinc-500">Started</span>
                        <p id="drawer-started" class="font-mono text-zinc-700 dark:text-zinc-300 mt-1 text-xs"></p>
                    </div>
                    <div>
                        <span class="text-xs uppercase tracking-wider text-zinc-500">Completed</span>
                        <p id="drawer-completed" class="font-mono text-zinc-700 dark:text-zinc-300 mt-1 text-xs"></p>
                    </div>
                </div>
            </div>
            <!-- Error section -->
            <div id="drawer-error-section" class="hidden">
                <p class="text-xs uppercase tracking-wider text-red-500 dark:text-red-400 mb-2">Error</p>
                <pre id="drawer-error" class="text-xs text-red-600 dark:text-red-300 bg-red-500/10 border border-red-500/30 p-4 rounded-xl whitespace-pre-wrap break-words font-mono max-h-48 overflow-auto"></pre>
            </div>
            <!-- Request section -->
            <div>
                <p class="text-xs uppercase tracking-wider text-zinc-500 mb-2">Request</p>
                <pre id="drawer-request" class="text-xs text-zinc-700 dark:text-zinc-300 bg-white/40 dark:bg-zinc-800/40 border border-white/20 dark:border-zinc-700/50 p-4 rounded-xl whitespace-pre-wrap break-words font-mono max-h-64 overflow-auto"></pre>
            </div>
            <!-- Response section -->
            <div>
                <p class="text-xs uppercase tracking-wider text-zinc-500 mb-2">Response</p>
                <pre id="drawer-response" class="text-xs text-zinc-700 dark:text-zinc-300 bg-white/40 dark:bg-zinc-800/40 border border-white/20 dark:border-zinc-700/50 p-4 rounded-xl whitespace-pre-wrap break-words font-mono max-h-64 overflow-auto"></pre>
            </div>
            <!-- Attempt history -->
            <div id="drawer-history-section" class="hidden">
                <p class="text-xs uppercase tracking-wider text-zinc-500 mb-2">All Attempts</p>
                <div id="drawer-history" class="space-y-2"></div>
            </div>
        </div>
    </div>
</div>
<!-- Backdrop (invisible - just for click-to-close) -->
<div id="detail-backdrop" class="fixed inset-0 z-40 opacity-0 pointer-events-none transition-opacity duration-300"></div>
{% endblock content %}

{% block scripts %}
<script>
const runDataUrl = "/api/workflows/{{ workflow.id }}/run/{{ instance.id }}/run-data";
const runActionLogsUrl = "/api/workflows/{{ workflow.id }}/run/{{ instance.id }}/action-logs";
const exportUrl = "/api/workflows/{{ workflow.id }}/run/{{ instance.id }}/export";

async function exportInstance() {
  const btn = document.getElementById('export-btn');
  const originalText = btn.innerHTML;
  btn.disabled = true;
  btn.innerHTML = `
    <svg class="h-4 w-4 animate-spin" fill="none" viewBox="0 0 24 24">
      <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
      <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
    </svg>
    Exporting...
  `;

  try {
    const response = await fetch(exportUrl);
    if (!response.ok) {
      throw new Error(`Export failed (${response.status})`);
    }
    const data = await response.json();

    // Create and download the file
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `workflow-instance-{{ instance.id }}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } catch (err) {
    console.error('Export failed:', err);
    alert('Failed to export workflow instance: ' + err.message);
  } finally {
    btn.disabled = false;
    btn.innerHTML = originalText;
  }
}
let nodeData = [];
const graphData = {{ graph_data | json_encode | safe }};
const actionLogsCache = {};
let timelineEntries = [];
let timelinePage = 1;
let timelineHasMore = false;
const timelinePerPage = 200;

async function loadRunData({ page = 1, append = false } = {}) {
  const emptyTimeline = document.querySelector('#timeline-empty p');
  if (emptyTimeline && page === 1 && !append) {
    emptyTimeline.textContent = 'Loading execution logs...';
  }

  const url = new URL(runDataUrl, window.location.origin);
  url.searchParams.set('page', String(page));
  url.searchParams.set('per_page', String(timelinePerPage));
  if (append) {
    url.searchParams.set('include_nodes', 'false');
  }

  const response = await fetch(url.toString());
  if (!response.ok) {
    throw new Error(`Failed to load run data (${response.status})`);
  }

  const payload = await response.json();
  if (!append) {
    nodeData = Array.isArray(payload.nodes) ? payload.nodes : [];
  }
  const pageEntries = Array.isArray(payload.timeline) ? payload.timeline : [];
  timelineEntries = append ? timelineEntries.concat(pageEntries) : pageEntries;
  timelinePage = Number.isFinite(payload.page) ? payload.page : page;
  timelineHasMore = Boolean(payload.has_more);
}

async function loadActionLogs(actionId) {
  if (actionLogsCache[actionId]) {
    return actionLogsCache[actionId];
  }

  const response = await fetch(`${runActionLogsUrl}/${actionId}`);
  if (!response.ok) {
    throw new Error(`Failed to load action logs (${response.status})`);
  }

  const payload = await response.json();
  const logs = Array.isArray(payload.logs) ? payload.logs : [];
  actionLogsCache[actionId] = logs;
  return logs;
}

function payloadHasException(payloadText) {
  if (!payloadText) return false;
  try {
    const parsed = JSON.parse(payloadText);
    if (parsed && typeof parsed === 'object' && parsed.error) {
      return true;
    }
  } catch (_err) {
    if (payloadText.includes('"__exception__"')) {
      return true;
    }
  }
  return false;
}

function deriveNodeStatus(node) {
  if (!node) return 'pending';
  if (node.status === 'failed' || node.status === 'exhausted' || node.status === 'timed_out') {
    return 'failed';
  }
  if (node.last_error) {
    return 'failed';
  }
  if (payloadHasException(node.response_payload)) {
    return 'failed';
  }
  return node.status || 'pending';
}

/**
 * DAGLayout - Reusable class for rendering DAG visualizations
 */
class DAGLayout {
  constructor(container, options = {}) {
    this.container = container;
    this.options = {
      orientation: options.orientation || 'horizontal',
      minNodeWidth: options.minNodeWidth || 120,
      maxNodeWidth: options.maxNodeWidth || 280,
      nodeHeight: options.nodeHeight || 64,
      padding: options.padding || 24,
      gap: options.gap || 80,
      rowGap: options.rowGap || 80,
      onNodeClick: options.onNodeClick || null,
      isDark: document.documentElement.classList.contains('dark'),
    };
    this.positions = new Map();
    this.nodeElements = new Map();
    this.nodeWidths = new Map();
  }

  measureNodeWidth(node) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = '600 14px system-ui, sans-serif';
    const actionWidth = ctx.measureText(node.action).width;
    ctx.font = '500 10px ui-monospace, monospace';
    const idWidth = ctx.measureText(node.id).width;
    ctx.font = '400 10px system-ui, sans-serif';
    const moduleWidth = ctx.measureText(node.module).width;
    const textWidth = Math.max(actionWidth, idWidth, moduleWidth);
    const paddedWidth = textWidth + 32;
    return Math.max(this.options.minNodeWidth, Math.min(paddedWidth, this.options.maxNodeWidth));
  }

  getStatusColors(status) {
    const isDark = document.documentElement.classList.contains('dark');
    // Modern style: transparent fill with colored border (matching badge style)
    const colors = {
      'completed': {
        bg: isDark ? 'rgba(16, 185, 129, 0.1)' : 'rgba(16, 185, 129, 0.08)',
        border: isDark ? 'rgba(16, 185, 129, 0.5)' : 'rgba(16, 185, 129, 0.4)',
        text: isDark ? '#34d399' : '#059669',
        label: isDark ? '#6ee7b7' : '#047857'
      },
      'failed': {
        bg: isDark ? 'rgba(239, 68, 68, 0.1)' : 'rgba(239, 68, 68, 0.08)',
        border: isDark ? 'rgba(239, 68, 68, 0.5)' : 'rgba(239, 68, 68, 0.4)',
        text: isDark ? '#f87171' : '#dc2626',
        label: isDark ? '#fca5a5' : '#b91c1c'
      },
      'dispatched': {
        bg: isDark ? 'rgba(245, 158, 11, 0.1)' : 'rgba(245, 158, 11, 0.08)',
        border: isDark ? 'rgba(245, 158, 11, 0.5)' : 'rgba(245, 158, 11, 0.4)',
        text: isDark ? '#fbbf24' : '#d97706',
        label: isDark ? '#fcd34d' : '#b45309'
      },
      'pending': {
        bg: isDark ? 'rgba(113, 113, 122, 0.1)' : 'rgba(113, 113, 122, 0.08)',
        border: isDark ? 'rgba(113, 113, 122, 0.4)' : 'rgba(113, 113, 122, 0.3)',
        text: isDark ? '#a1a1aa' : '#71717a',
        label: isDark ? '#d4d4d8' : '#52525b'
      },
      'queued': {
        bg: isDark ? 'rgba(59, 130, 246, 0.1)' : 'rgba(59, 130, 246, 0.08)',
        border: isDark ? 'rgba(59, 130, 246, 0.5)' : 'rgba(59, 130, 246, 0.4)',
        text: isDark ? '#60a5fa' : '#2563eb',
        label: isDark ? '#93c5fd' : '#1d4ed8'
      }
    };
    return colors[status] || colors['pending'];
  }

  getNodeColors(node) {
    // Sleep nodes always use blue, regardless of status
    if (node.is_sleep) {
      const isDark = document.documentElement.classList.contains('dark');
      return {
        bg: isDark ? 'rgba(59, 130, 246, 0.1)' : 'rgba(59, 130, 246, 0.08)',
        border: isDark ? 'rgba(59, 130, 246, 0.5)' : 'rgba(59, 130, 246, 0.4)',
        text: isDark ? '#60a5fa' : '#2563eb',
        label: isDark ? '#93c5fd' : '#1d4ed8'
      };
    }
    return this.getStatusColors(node.status);
  }

  render(nodes) {
    if (!nodes || !nodes.length) return;
    this.container.innerHTML = '';
    const nodeMap = new Map(nodes.map(n => [n.id, n]));
    const depthCache = new Map();
    nodes.forEach(node => { this.nodeWidths.set(node.id, this.measureNodeWidth(node)); });

    const computeDepth = (nodeId, stack = new Set()) => {
      if (depthCache.has(nodeId)) return depthCache.get(nodeId);
      const node = nodeMap.get(nodeId);
      if (!node || !node.depends_on || !node.depends_on.length) { depthCache.set(nodeId, 0); return 0; }
      if (stack.has(nodeId)) return 0;
      stack.add(nodeId);
      let depth = 0;
      node.depends_on.forEach(dep => { depth = Math.max(depth, computeDepth(dep, stack) + 1); });
      stack.delete(nodeId);
      depthCache.set(nodeId, depth);
      return depth;
    };

    const levels = [];
    nodes.forEach(node => { const depth = computeDepth(node.id); if (!levels[depth]) levels[depth] = []; levels[depth].push(node); });
    levels.forEach(level => { if (level) level.sort((a, b) => a.id.localeCompare(b.id)); });

    const normalizedLevels = Array.from({ length: levels.length }, (_, i) => levels[i] || []);
    const { nodeHeight, padding, gap, rowGap, orientation } = this.options;
    const levelMaxWidths = normalizedLevels.map(levelNodes => Math.max(...levelNodes.map(n => this.nodeWidths.get(n.id)), this.options.minNodeWidth));
    const maxDepth = normalizedLevels.length;
    const maxNodesInLevel = Math.max(...normalizedLevels.map(l => l.length), 1);

    let totalWidth, totalHeight;
    if (orientation === 'vertical') {
      const maxLevelWidth = Math.max(...normalizedLevels.map(levelNodes => levelNodes.reduce((sum, n) => sum + this.nodeWidths.get(n.id), 0) + (levelNodes.length - 1) * (rowGap / 2)), 0);
      totalWidth = padding * 2 + maxLevelWidth;
      totalHeight = padding * 2 + maxDepth * gap + nodeHeight;
    } else {
      const levelWidthsSum = levelMaxWidths.reduce((sum, w) => sum + w, 0);
      totalWidth = padding * 2 + levelWidthsSum + (maxDepth - 1) * gap;
      // Height = padding + (n-1) * (nodeHeight + gap) + nodeHeight + padding
      totalHeight = padding * 2 + maxNodesInLevel * nodeHeight + (maxNodesInLevel - 1) * 20;
    }

    const wrapper = document.createElement('div');
    wrapper.style.cssText = `position: relative; width: ${totalWidth}px; height: ${Math.max(totalHeight, 150)}px;`;
    this.container.appendChild(wrapper);

    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.style.cssText = 'position: absolute; top: 0; left: 0; pointer-events: none;';
    svg.setAttribute('width', totalWidth);
    svg.setAttribute('height', Math.max(totalHeight, 150));
    wrapper.appendChild(svg);

    const levelStartX = [];
    let cumX = padding;
    levelMaxWidths.forEach((w, i) => { levelStartX[i] = cumX; cumX += w + gap; });

    normalizedLevels.forEach((levelNodes, depth) => {
      levelNodes.forEach((node, index) => {
        const nodeWidth = this.nodeWidths.get(node.id);
        const levelMaxWidth = levelMaxWidths[depth];
        let left, top;
        if (orientation === 'vertical') {
          const levelTotalWidth = levelNodes.reduce((sum, n, i) => sum + this.nodeWidths.get(n.id) + (i > 0 ? rowGap / 2 : 0), 0);
          let runningX = padding + (totalWidth - padding * 2 - levelTotalWidth) / 2;
          for (let i = 0; i < index; i++) { runningX += this.nodeWidths.get(levelNodes[i].id) + rowGap / 2; }
          left = runningX;
          top = padding + depth * gap;
        } else {
          left = levelStartX[depth] + (levelMaxWidth - nodeWidth) / 2;
          // Space nodes vertically with nodeHeight + gap between them
          top = padding + index * (nodeHeight + 20);
        }
        this.positions.set(node.id, { x: left + nodeWidth / 2, y: top + nodeHeight / 2, left, top, width: nodeWidth });
        const el = this.createNodeElement(node, left, top, nodeWidth);
        wrapper.appendChild(el);
        this.nodeElements.set(node.id, el);
      });
    });

    const isDark = document.documentElement.classList.contains('dark');
    const strokeColor = isDark ? 'rgba(113, 113, 122, 0.4)' : 'rgba(161, 161, 170, 0.5)';
    nodes.forEach(node => {
      if (!node.depends_on) return;
      node.depends_on.forEach(depId => {
        const start = this.positions.get(depId);
        const end = this.positions.get(node.id);
        if (!start || !end) return;
        const startWidth = start.width || this.options.minNodeWidth;
        const endWidth = end.width || this.options.minNodeWidth;
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        let d;
        if (orientation === 'vertical') {
          const midY = (start.y + end.y) / 2;
          d = `M${start.x},${start.y + nodeHeight/2} C${start.x},${midY} ${end.x},${midY} ${end.x},${end.y - nodeHeight/2}`;
        } else {
          const midX = (start.x + end.x) / 2;
          d = `M${start.x + startWidth/2},${start.y} C${midX},${start.y} ${midX},${end.y} ${end.x - endWidth/2},${end.y}`;
        }
        path.setAttribute('d', d);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', strokeColor);
        path.setAttribute('stroke-width', '1.5');
        path.setAttribute('stroke-linecap', 'round');
        svg.appendChild(path);
      });
    });
  }

  createNodeElement(node, left, top, nodeWidth) {
    const { nodeHeight } = this.options;
    const colors = this.getNodeColors(node);
    const el = document.createElement('div');
    el.className = 'absolute rounded-xl px-3 py-2.5 cursor-pointer transition-all duration-150 hover:scale-[1.02]';
    el.style.cssText = `left: ${left}px; top: ${top}px; width: ${nodeWidth}px; min-height: ${nodeHeight}px; background: ${colors.bg}; border: 1px solid ${colors.border}; overflow: hidden; backdrop-filter: blur(8px);`;
    el.dataset.nodeId = node.id;
    el.innerHTML = `
      <p class="text-[10px] font-mono font-medium uppercase tracking-wide truncate opacity-70" style="color: ${colors.label}">${node.id}</p>
      <p class="text-sm font-medium truncate mt-1" style="color: ${colors.text}">${node.action}</p>
      <p class="text-[10px] truncate opacity-50 mt-0.5" style="color: ${colors.text}">${node.module}</p>
    `;
    if (this.options.onNodeClick) { el.addEventListener('click', () => this.options.onNodeClick(node.id)); }
    return el;
  }

  selectNode(nodeId) {
    this.nodeElements.forEach(el => { el.classList.remove('ring-2', 'ring-indigo-500', 'ring-offset-2'); });
    const el = this.nodeElements.get(nodeId);
    if (el) { el.classList.add('ring-2', 'ring-indigo-500', 'ring-offset-2'); }
  }
}

/**
 * GanttTimeline - Renders a modern Gantt-style timeline
 */
class GanttTimeline {
  constructor(container, options = {}) {
    this.container = container;
    this.options = {
      rowHeight: options.rowHeight || 44,
      headerHeight: options.headerHeight || 48,
      timeAxisHeight: options.timeAxisHeight || 32,
      minBarWidth: options.minBarWidth || 80,
      onItemClick: options.onItemClick || null,
    };
    this.rows = [];
  }

  render(entries) {
    if (!entries || !entries.length) {
      this.container.innerHTML = '';
      return;
    }

    // Sort by dispatched_at
    const sorted = [...entries].sort((a, b) => new Date(a.dispatched_at).getTime() - new Date(b.dispatched_at).getTime());

    // Calculate time bounds
    let minTime = Infinity, maxTime = -Infinity;
    sorted.forEach(entry => {
      const start = new Date(entry.dispatched_at).getTime();
      const end = entry.completed_at ? new Date(entry.completed_at).getTime() : start + (entry.duration_ms || 100);
      minTime = Math.min(minTime, start);
      maxTime = Math.max(maxTime, end);
    });

    const timeRange = maxTime - minTime || 1000;
    const timePadding = timeRange * 0.02;
    minTime -= timePadding;
    maxTime += timePadding;
    const totalDuration = maxTime - minTime;
    const workflowDuration = maxTime - minTime - (timePadding * 2);

    const { rowHeight, headerHeight, timeAxisHeight, minBarWidth } = this.options;
    const chartHeight = sorted.length * rowHeight + headerHeight + timeAxisHeight;

    // Build HTML
    let html = `
      <div class="flex flex-col" style="min-width: 100%;">
        <!-- Header bar -->
        <div class="flex items-center justify-between px-5 border-b border-zinc-200 dark:border-zinc-800 bg-zinc-50 dark:bg-zinc-900" style="height: ${headerHeight}px;">
          <div class="flex items-center gap-3">
            <div class="w-2 h-2 rounded-full bg-blue-500"></div>
            <span class="text-sm font-medium text-blue-600 dark:text-blue-400">workflow()</span>
          </div>
          <span class="text-sm font-mono text-zinc-500">${this.formatDuration(workflowDuration)}</span>
        </div>

        <!-- Chart area -->
        <div class="relative overflow-x-auto">
          <!-- Time axis -->
          <div class="sticky top-0 z-10 flex items-end border-b border-zinc-200 dark:border-zinc-800 bg-white dark:bg-zinc-950" style="height: ${timeAxisHeight}px;">
            <div class="flex-1 relative px-4">
              ${this.renderTimeAxis(minTime, maxTime)}
            </div>
          </div>

          <!-- Rows with grid lines -->
          <div class="relative bg-grid">
            <!-- Row content -->
            ${sorted.map((entry, idx) => this.renderRow(entry, idx, minTime, totalDuration)).join('')}
          </div>
        </div>
      </div>
    `;

    this.container.innerHTML = html;
    this.rows = sorted;

    // Bind click handlers
    this.container.querySelectorAll('[data-entry-idx]').forEach(el => {
      el.addEventListener('click', () => {
        const idx = parseInt(el.dataset.entryIdx, 10);
        if (this.options.onItemClick && this.rows[idx]) {
          this.options.onItemClick(this.rows[idx]);
        }
      });
    });
  }

  renderStripes(count) {
    let stripes = '';
    for (let i = 0; i < count; i++) {
      const bg = i % 2 === 0 ? 'bg-zinc-900/40' : 'bg-zinc-950/40';
      stripes += `<div class="${bg} flex-1"></div>`;
    }
    return stripes;
  }

  renderTimeAxis(minTime, maxTime) {
    const tickCount = 7;
    const range = maxTime - minTime;
    let ticks = '';
    for (let i = 0; i <= tickCount; i++) {
      const pct = (i / tickCount) * 100;
      const time = minTime + range * (i / tickCount);
      const date = new Date(time);
      // Show relative time from start for cleaner display
      const relativeMs = time - minTime;
      let label;
      if (relativeMs === 0) {
        label = '0ms';
      } else if (relativeMs < 1000) {
        label = `+${Math.round(relativeMs)}ms`;
      } else {
        label = `+${(relativeMs / 1000).toFixed(1)}s`;
      }
      ticks += `<span class="absolute bottom-1 text-[10px] font-mono text-zinc-500 transform -translate-x-1/2" style="left: ${pct}%;">${label}</span>`;
    }
    return ticks;
  }

  renderRow(entry, idx, minTime, totalDuration) {
    const { rowHeight, minBarWidth } = this.options;
    const start = new Date(entry.dispatched_at).getTime();
    const duration = entry.duration_ms || 100;
    const end = entry.completed_at ? new Date(entry.completed_at).getTime() : start + duration;

    const startPct = ((start - minTime) / totalDuration) * 100;
    const widthPct = ((end - start) / totalDuration) * 100;

    // Status colors - transparent fill with colored border (matching badge style)
    // Sleep nodes always use blue, regardless of status
    let borderColor, textColor, bgColor;
    if (entry.is_sleep) {
      borderColor = 'border-blue-500/60';
      textColor = 'text-blue-600 dark:text-blue-400';
      bgColor = 'bg-blue-500/10';
    } else if (entry.success === true) {
      borderColor = 'border-emerald-500/60';
      textColor = 'text-emerald-600 dark:text-emerald-400';
      bgColor = 'bg-emerald-500/10';
    } else if (entry.success === false) {
      borderColor = 'border-red-500/60';
      textColor = 'text-red-600 dark:text-red-400';
      bgColor = 'bg-red-500/10';
    } else {
      borderColor = 'border-amber-500/60';
      textColor = 'text-amber-600 dark:text-amber-400';
      bgColor = 'bg-amber-500/10';
    }

    const actionName = entry.actionName || entry.action_name || 'Unknown';
    const durationText = this.formatDuration(duration);

    return `
      <div class="relative flex items-center px-4" style="height: ${rowHeight}px;" data-entry-idx="${idx}">
        <div
          class="absolute flex items-center justify-between gap-2 px-3 rounded-lg border ${borderColor} ${bgColor} cursor-pointer hover:bg-opacity-20 transition-colors"
          style="left: calc(${startPct}% + 16px); width: max(${widthPct}%, ${minBarWidth}px); height: ${rowHeight - 12}px;"
        >
          <span class="text-xs font-medium ${textColor} truncate">${actionName}()</span>
          <span class="text-[10px] font-mono text-zinc-500 whitespace-nowrap">${durationText}</span>
        </div>
      </div>
    `;
  }

  formatDuration(ms) {
    if (ms < 1000) return `${Math.round(ms)}ms`;
    if (ms < 60000) return `${(ms / 1000).toFixed(2)}s`;
    const mins = Math.floor(ms / 60000);
    const secs = ((ms % 60000) / 1000).toFixed(1);
    return `${mins}m ${secs}s`;
  }
}

// Drawer management
let drawerOpen = false;

function openDrawer(entry, nodeInfo) {
  const drawer = document.getElementById('detail-drawer');
  const backdrop = document.getElementById('detail-backdrop');

  const actionName = entry.actionName || entry.action_name || 'Unknown';
  const moduleName = entry.moduleName || entry.module_name || '';

  document.getElementById('drawer-title').textContent = actionName;
  document.getElementById('drawer-subtitle').textContent = moduleName;

  // Status - sleep nodes always use blue
  const statusEl = document.getElementById('drawer-status');
  statusEl.className = 'rounded-lg px-2.5 py-1 text-xs font-semibold uppercase tracking-wide border';
  if (entry.is_sleep) {
    statusEl.textContent = entry.success === true ? 'Completed' : entry.success === false ? 'Failed' : 'Sleeping';
    statusEl.classList.add('border-blue-500/50', 'bg-blue-500/10', 'text-blue-600', 'dark:text-blue-400');
  } else if (entry.success === true) {
    statusEl.textContent = 'Success';
    statusEl.classList.add('border-emerald-500/50', 'bg-emerald-500/10', 'text-emerald-600', 'dark:text-emerald-400');
  } else if (entry.success === false) {
    statusEl.textContent = 'Failed';
    statusEl.classList.add('border-red-500/50', 'bg-red-500/10', 'text-red-600', 'dark:text-red-400');
  } else {
    statusEl.textContent = 'Running';
    statusEl.classList.add('border-amber-500/50', 'bg-amber-500/10', 'text-amber-600', 'dark:text-amber-400');
  }

  // Duration
  const durationMs = entry.duration_ms;
  let durationText = '-';
  if (durationMs !== null && durationMs !== undefined) {
    durationText = durationMs < 1000 ? durationMs + 'ms' : (durationMs / 1000).toFixed(2) + 's';
  }
  document.getElementById('drawer-duration').textContent = `Duration: ${durationText}`;

  // Timing
  document.getElementById('drawer-started').textContent = entry.dispatched_at || '-';
  document.getElementById('drawer-completed').textContent = entry.completed_at || '-';

  // Error
  const errorSection = document.getElementById('drawer-error-section');
  if (entry.error_message) {
    errorSection.classList.remove('hidden');
    document.getElementById('drawer-error').textContent = entry.error_message;
  } else {
    errorSection.classList.add('hidden');
  }

  // Request/Response
  const requestPayload = nodeInfo?.request_payload || '{}';
  const responsePayload = entry.result_payload || nodeInfo?.response_payload || '{}';
  document.getElementById('drawer-request').textContent = requestPayload;
  document.getElementById('drawer-response').textContent = responsePayload;

  // Load history
  const historySection = document.getElementById('drawer-history-section');
  const historyContainer = document.getElementById('drawer-history');

  if (entry.action_id) {
    historySection.classList.remove('hidden');
    historyContainer.innerHTML = '<div class="text-xs text-zinc-500">Loading...</div>';

    loadActionLogs(entry.action_id).then(logs => {
      if (logs.length <= 1) { historySection.classList.add('hidden'); return; }
      historyContainer.innerHTML = '';
      logs.forEach(log => {
        const row = document.createElement('div');
        row.className = 'rounded-lg bg-zinc-800/50 p-3 text-xs';
        let statusColor = log.success === true ? 'text-emerald-400' : log.success === false ? 'text-red-400' : 'text-amber-400';
        let statusText = log.success === true ? 'Success' : log.success === false ? 'Failed' : 'Running';
        let logDuration = log.duration_ms !== null && log.duration_ms !== undefined
          ? (log.duration_ms < 1000 ? log.duration_ms + 'ms' : (log.duration_ms / 1000).toFixed(2) + 's')
          : '-';
        row.innerHTML = `
          <div class="flex items-center justify-between">
            <span class="font-semibold text-zinc-200">Attempt ${log.attempt_number + 1}</span>
            <span class="font-semibold ${statusColor}">${statusText}</span>
          </div>
          <div class="mt-1 text-zinc-500">Started: ${log.dispatched_at} | Duration: ${logDuration}</div>
          ${log.error_message ? `<div class="mt-1 text-red-400 truncate">${escapeHtml(log.error_message)}</div>` : ''}
        `;
        historyContainer.appendChild(row);
      });
    }).catch(() => {
      historyContainer.innerHTML = '<div class="text-xs text-zinc-500">Failed to load history</div>';
    });
  } else {
    historySection.classList.add('hidden');
  }

  // Open drawer
  drawer.classList.remove('translate-x-full');
  backdrop.classList.remove('opacity-0', 'pointer-events-none');
  backdrop.classList.add('opacity-100', 'pointer-events-auto');
  drawerOpen = true;
}

function closeDrawer() {
  const drawer = document.getElementById('detail-drawer');
  const backdrop = document.getElementById('detail-backdrop');
  drawer.classList.add('translate-x-full');
  backdrop.classList.add('opacity-0', 'pointer-events-none');
  backdrop.classList.remove('opacity-100', 'pointer-events-auto');
  drawerOpen = false;
}

document.addEventListener('DOMContentLoaded', () => {
  loadRunData()
    .then(() => initRunPage())
    .catch((err) => {
      console.error(err);
      const emptyTimeline = document.querySelector('#timeline-empty p');
      if (emptyTimeline) { emptyTimeline.textContent = 'Failed to load execution logs.'; }
      initRunPage(true);
    });

  document.getElementById('drawer-close').addEventListener('click', closeDrawer);
  document.getElementById('detail-backdrop').addEventListener('click', closeDrawer);
  document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && drawerOpen) closeDrawer(); });
});

function initRunPage(loadError) {
  const container = document.getElementById('execution-graph');
  if (!container) return;

  const nodeLookup = {};
  nodeData.forEach(n => { nodeLookup[n.id] = n; });

  const actionLookup = {};
  nodeData.forEach(n => { if (n.action_id) actionLookup[n.action_id] = n; });

  const nodes = graphData?.nodes || [];
  nodes.forEach(n => {
    if (nodeLookup[n.id]) {
      const d = nodeLookup[n.id];
      n.module = d.module;
      n.action = d.action;
      n.status = deriveNodeStatus(d);
    }
  });

  if (nodes.length) {
    const placeholder = document.getElementById('graph-empty');
    if (placeholder) placeholder.remove();
    const dag = new DAGLayout(container, {
      orientation: 'horizontal',
      minNodeWidth: 140, maxNodeWidth: 280, nodeHeight: 64,
      padding: 24, gap: 80, rowGap: 80, onNodeClick: null
    });
    dag.render(nodes);
  }

  renderGanttTimeline(actionLookup);
  renderExecutionLog(actionLookup);

  const loadMoreButton = document.getElementById('log-load-more');
  if (loadMoreButton) {
    loadMoreButton.onclick = async () => {
      loadMoreButton.disabled = true;
      loadMoreButton.textContent = 'Loading...';
      try {
        await loadRunData({ page: timelinePage + 1, append: true });
        renderGanttTimeline(actionLookup);
        renderExecutionLog(actionLookup);
      } catch (err) { console.error(err); }
      finally { loadMoreButton.textContent = 'Load more'; loadMoreButton.disabled = false; }
    };
  }
}

function renderGanttTimeline(actionLookup) {
  const timelineEmpty = document.getElementById('timeline-empty');
  const timelineGantt = document.getElementById('timeline-gantt');
  if (!timelineEmpty || !timelineGantt) return;

  if (timelineEntries.length === 0) {
    timelineEmpty.classList.remove('hidden');
    timelineGantt.classList.add('hidden');
    return;
  }

  const actionInfoLookup = {};
  nodeData.forEach(n => { actionInfoLookup[n.action_id] = { nodeId: n.id, action: n.action, module: n.module }; });

  const resolvedLogs = timelineEntries.map((log) => {
    const info = actionInfoLookup[log.action_id];
    return { ...log, nodeId: info?.nodeId || log.node_id || log.action_id, actionName: info?.action || log.action_name || 'Unknown', moduleName: info?.module || log.module_name || '' };
  });

  timelineEmpty.classList.add('hidden');
  timelineGantt.classList.remove('hidden');

  const gantt = new GanttTimeline(timelineGantt, {
    rowHeight: 44, headerHeight: 48, timeAxisHeight: 32, minBarWidth: 100,
    onItemClick: (entry) => { openDrawer(entry, actionLookup[entry.action_id]); }
  });
  gantt.render(resolvedLogs);
}

function renderExecutionLog(actionLookup) {
  const logEmpty = document.getElementById('log-empty');
  const logContent = document.getElementById('log-content');
  const loadMoreContainer = document.getElementById('log-load-more-container');
  if (!logEmpty || !logContent) return;

  if (timelineEntries.length === 0) {
    logEmpty.classList.remove('hidden');
    logContent.classList.add('hidden');
    if (loadMoreContainer) loadMoreContainer.classList.add('hidden');
    return;
  }

  const actionInfoLookup = {};
  nodeData.forEach(n => { actionInfoLookup[n.action_id] = { nodeId: n.id, action: n.action, module: n.module }; });

  const resolvedLogs = timelineEntries.map((log) => {
    const info = actionInfoLookup[log.action_id];
    return { ...log, nodeId: info?.nodeId || log.node_id || log.action_id, actionName: info?.action || log.action_name || 'Unknown', moduleName: info?.module || log.module_name || '' };
  });

  logEmpty.classList.add('hidden');
  logContent.classList.remove('hidden');
  logContent.innerHTML = '';

  resolvedLogs.forEach((log, idx) => {
    const row = document.createElement('div');
    row.className = 'transition-colors';

    // Sleep nodes always use blue, regardless of status
    let statusColor, statusBg, statusBorder, statusText, ringColor, dotColor;
    if (log.is_sleep) {
      statusColor = 'text-blue-600 dark:text-blue-400';
      statusBg = 'bg-blue-500/10';
      statusBorder = 'border-blue-500/50';
      statusText = log.success === true ? 'Completed' : log.success === false ? 'Failed' : 'Sleeping';
      ringColor = 'ring-blue-500';
      dotColor = 'bg-blue-500';
    } else if (log.success === true) {
      statusColor = 'text-emerald-600 dark:text-emerald-400';
      statusBg = 'bg-emerald-500/10';
      statusBorder = 'border-emerald-500/50';
      statusText = 'Success';
      ringColor = 'ring-emerald-500';
      dotColor = 'bg-emerald-500';
    } else if (log.success === false) {
      statusColor = 'text-red-600 dark:text-red-400';
      statusBg = 'bg-red-500/10';
      statusBorder = 'border-red-500/50';
      statusText = 'Failed';
      ringColor = 'ring-red-500';
      dotColor = 'bg-red-500';
    } else {
      statusColor = 'text-amber-600 dark:text-amber-400';
      statusBg = 'bg-amber-500/10';
      statusBorder = 'border-amber-500/50';
      statusText = 'Running';
      ringColor = 'ring-amber-500';
      dotColor = 'bg-amber-500';
    }

    let durationText = '-';
    if (log.duration_ms !== null && log.duration_ms !== undefined) {
      durationText = log.duration_ms < 1000 ? log.duration_ms + 'ms' : (log.duration_ms / 1000).toFixed(2) + 's';
    }

    const hasDetails = log.result_payload || log.error_message;
    const expandId = `log-expand-${idx}`;

    row.innerHTML = `
      <div class="flex items-center gap-4 p-4 ${hasDetails ? 'cursor-pointer hover:bg-zinc-50 dark:hover:bg-zinc-900/50' : ''}" ${hasDetails ? `onclick="toggleLogExpand('${expandId}')"` : ''}>
        <div class="flex flex-col items-center">
          <div class="w-2 h-2 rounded-full ${dotColor}"></div>
        </div>
        <div class="flex-1 min-w-0">
          <div class="flex items-center gap-2 flex-wrap">
            <span class="font-medium text-zinc-800 dark:text-zinc-200">${log.actionName}</span>
            <span class="text-xs text-zinc-400 font-mono">${log.moduleName}</span>
            <span class="inline-flex items-center text-xs px-2 py-0.5 rounded-full border font-medium ${statusBg} ${statusBorder} ${statusColor}">${statusText}</span>
          </div>
          <div class="flex items-center gap-4 mt-1.5 text-xs text-zinc-500">
            <span>Started: <span class="text-zinc-600 dark:text-zinc-400 font-mono">${log.dispatched_at}</span></span>
            <span>Duration: <span class="text-zinc-600 dark:text-zinc-400 font-mono">${durationText}</span></span>
          </div>
        </div>
        <div class="flex items-center gap-3">
          <span class="text-xs text-zinc-400 tabular-nums">Attempt ${log.attempt_number + 1}</span>
          ${hasDetails ? `<svg class="w-4 h-4 text-zinc-400 transition-transform" id="${expandId}-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>` : ''}
        </div>
      </div>
      ${hasDetails ? `
      <div id="${expandId}" class="hidden border-t border-zinc-100 dark:border-zinc-800/50 px-4 py-4 ml-6 space-y-3 bg-zinc-50 dark:bg-zinc-900/30">
        ${log.error_message ? `
        <div>
          <p class="text-xs uppercase tracking-wider text-red-500 dark:text-red-400 mb-1.5 font-medium">Error</p>
          <pre class="text-xs text-red-600 dark:text-red-300 bg-red-50 dark:bg-red-950/30 border border-red-200 dark:border-red-900/50 p-3 rounded-lg whitespace-pre-wrap break-words font-mono overflow-x-auto max-h-32">${escapeHtml(log.error_message)}</pre>
        </div>
        ` : ''}
        ${log.result_payload ? `
        <div>
          <p class="text-xs uppercase tracking-wider text-zinc-500 mb-1.5 font-medium">${log.success === false ? 'Exception' : 'Result'}</p>
          <pre class="text-xs text-zinc-600 dark:text-zinc-300 bg-zinc-100 dark:bg-zinc-900/50 border border-zinc-200 dark:border-zinc-800 p-3 rounded-lg whitespace-pre-wrap break-words font-mono overflow-x-auto max-h-64">${escapeHtml(log.result_payload)}</pre>
        </div>
        ` : ''}
      </div>
      ` : ''}
    `;

    logContent.appendChild(row);
  });

  if (loadMoreContainer) {
    if (timelineHasMore) { loadMoreContainer.classList.remove('hidden'); }
    else { loadMoreContainer.classList.add('hidden'); }
  }
}

function toggleLogExpand(id) {
  const content = document.getElementById(id);
  const icon = document.getElementById(id + '-icon');
  if (content) {
    content.classList.toggle('hidden');
    if (icon) icon.classList.toggle('rotate-180');
  }
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}
</script>
{% endblock scripts %}
