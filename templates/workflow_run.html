{% extends "base.html" %}
{% import "macros.html" as macros %}

{% block title %}{{ title }}{% endblock title %}

{% block content %}
<section class="space-y-4">
    <a href="/workflows/{{ workflow.id }}" class="text-xs uppercase tracking-[0.4em] text-zinc-500 transition hover:text-zinc-700 dark:hover:text-zinc-300">&larr; Back to workflow detail</a>
    <div class="space-y-2">
        <h1 class="text-3xl font-semibold tracking-tight text-zinc-900 dark:text-white">Run {{ instance.id }}</h1>
        <p class="text-sm text-zinc-600 dark:text-zinc-400">{{ workflow.name }}</p>
    </div>
    <dl class="grid gap-4 rounded-2xl border border-zinc-200 dark:border-zinc-900 bg-zinc-100 dark:bg-zinc-900/40 p-6 md:grid-cols-2 lg:grid-cols-4">
        <div>
            <dt class="text-xs uppercase tracking-[0.4em] text-zinc-500">Version ID</dt>
            <dd class="text-lg font-semibold text-zinc-900 dark:text-white font-mono text-sm">{{ workflow.id }}</dd>
        </div>
        <div>
            <dt class="text-xs uppercase tracking-[0.4em] text-zinc-500">Run Created</dt>
            <dd class="text-lg font-semibold text-zinc-900 dark:text-white">{{ macros::datetime(timestamp=instance.created_at) }}</dd>
        </div>
        <div>
            <dt class="text-xs uppercase tracking-[0.4em] text-zinc-500">Status</dt>
            <dd class="text-lg font-semibold text-zinc-900 dark:text-white">{{ instance.status }}</dd>
        </div>
        <div>
            <dt class="text-xs uppercase tracking-[0.4em] text-zinc-500">Progress</dt>
            <dd class="text-lg font-semibold text-zinc-900 dark:text-white">{{ instance.progress }}</dd>
        </div>
    </dl>
</section>

<section class="grid gap-6 lg:grid-cols-2">
    <div class="rounded-2xl border border-zinc-200 dark:border-zinc-900 bg-zinc-100 dark:bg-zinc-900/40 p-5">
        <p class="text-xs uppercase tracking-[0.4em] text-zinc-500">Input Payload</p>
        <pre class="mt-3 overflow-x-auto whitespace-pre-wrap rounded-xl bg-zinc-200/70 dark:bg-zinc-950/70 p-4 text-xs text-zinc-800 dark:text-zinc-200">{{ instance.input_payload }}</pre>
    </div>
    <div class="rounded-2xl border border-zinc-200 dark:border-zinc-900 bg-zinc-100 dark:bg-zinc-900/40 p-5">
        <p class="text-xs uppercase tracking-[0.4em] text-zinc-500">Result Payload</p>
        <pre class="mt-3 overflow-x-auto whitespace-pre-wrap rounded-xl bg-zinc-200/70 dark:bg-zinc-950/70 p-4 text-xs text-zinc-800 dark:text-zinc-200">{{ instance.result_payload }}</pre>
    </div>
</section>

<section class="space-y-3">
    <div>
        <p class="text-xs uppercase tracking-[0.4em] text-zinc-500">Execution</p>
        <h2 class="text-2xl font-semibold text-zinc-900 dark:text-white">Execution Details</h2>
        <p class="text-sm text-zinc-600 dark:text-zinc-400">Click a node in the graph to view details</p>
    </div>
    <div class="grid gap-6 lg:grid-cols-2">
        <!-- Vertical DAG (left side) -->
        <div id="execution-graph" class="relative min-h-[400px] max-h-[600px] overflow-auto rounded-2xl border border-zinc-200 dark:border-zinc-900 bg-gradient-to-b from-zinc-50 to-zinc-100 dark:from-zinc-950 dark:to-zinc-900 p-4">
            <p id="graph-empty" class="p-6 text-sm text-zinc-600 dark:text-zinc-400">No DAG nodes to display.</p>
        </div>

        <!-- Detail panel (right side) -->
        <div id="detail-panel" class="rounded-2xl border border-zinc-200 dark:border-zinc-900 bg-zinc-100 dark:bg-zinc-900/40 p-5 lg:sticky lg:top-6 lg:self-start max-h-[600px] overflow-auto">
            <div id="detail-placeholder" class="text-center py-12 text-zinc-600 dark:text-zinc-400">
                <svg class="mx-auto h-12 w-12 text-zinc-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122m-5.657 5.656l-2.12 2.122" />
                </svg>
                <p class="mt-4 text-sm">Select a node to view details</p>
            </div>
            <div id="detail-content" class="hidden space-y-4">
                <div class="flex items-center justify-between gap-2">
                    <div>
                        <p id="detail-node-id" class="text-lg font-semibold text-zinc-900 dark:text-white"></p>
                        <p id="detail-action-info" class="text-sm text-zinc-700 dark:text-zinc-300"></p>
                    </div>
                    <span id="detail-status" class="rounded-full px-3 py-1 text-xs font-semibold uppercase tracking-wide"></span>
                </div>
                <!-- Error section (shown when there's an error) -->
                <div id="detail-error-info" class="hidden rounded-xl bg-red-100/50 dark:bg-red-900/20 border border-red-300 dark:border-red-700 p-3">
                    <p class="text-xs uppercase tracking-[0.4em] text-red-700 dark:text-red-400 mb-2">Error</p>
                    <pre id="detail-error-message" class="text-sm text-red-800 dark:text-red-200 whitespace-pre-wrap break-words font-mono"></pre>
                </div>
                <!-- Retry info section (shown when relevant) -->
                <div id="detail-retry-info" class="hidden rounded-xl bg-amber-100/50 dark:bg-amber-900/20 border border-amber-300 dark:border-amber-700 p-3">
                    <p class="text-xs uppercase tracking-[0.4em] text-amber-700 dark:text-amber-400 mb-2">Retry Status</p>
                    <div class="grid grid-cols-2 gap-2 text-sm">
                        <div>
                            <span class="text-zinc-600 dark:text-zinc-400">Attempts:</span>
                            <span id="detail-attempts" class="font-semibold text-zinc-900 dark:text-white"></span>
                        </div>
                        <div>
                            <span class="text-zinc-600 dark:text-zinc-400">Max Retries:</span>
                            <span id="detail-max-retries" class="font-semibold text-zinc-900 dark:text-white"></span>
                        </div>
                    </div>
                    <div id="detail-scheduled-row" class="mt-2 hidden">
                        <span class="text-zinc-600 dark:text-zinc-400 text-sm">Scheduled At:</span>
                        <span id="detail-scheduled-at" class="font-semibold text-zinc-900 dark:text-white text-sm"></span>
                    </div>
                </div>
                <div>
                    <p class="text-xs uppercase tracking-[0.4em] text-zinc-500">Request</p>
                    <pre id="detail-request" class="mt-2 max-h-64 overflow-auto whitespace-pre-wrap rounded-xl bg-zinc-200/70 dark:bg-zinc-950/70 p-3 text-xs text-zinc-800 dark:text-zinc-200 font-mono"></pre>
                </div>
                <div>
                    <p class="text-xs uppercase tracking-[0.4em] text-zinc-500">Response</p>
                    <pre id="detail-response" class="mt-2 max-h-64 overflow-auto whitespace-pre-wrap rounded-xl bg-zinc-200/70 dark:bg-zinc-950/70 p-3 text-xs text-zinc-800 dark:text-zinc-200 font-mono"></pre>
                </div>
                <!-- Execution History section (shows all run attempts) -->
                <div id="detail-history" class="hidden">
                    <p class="text-xs uppercase tracking-[0.4em] text-zinc-500 mb-2">Execution History</p>
                    <div id="detail-history-content" class="space-y-2 max-h-48 overflow-auto">
                        <!-- History rows will be injected here -->
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

<!-- Full Execution Timeline -->
<section class="space-y-3">
    <div>
        <p class="text-xs uppercase tracking-[0.4em] text-zinc-500">Timeline</p>
        <h2 class="text-2xl font-semibold text-zinc-900 dark:text-white">Execution Log</h2>
        <p class="text-sm text-zinc-600 dark:text-zinc-400">Chronological history of all action executions</p>
    </div>
    <div id="timeline-container" class="rounded-2xl border border-zinc-200 dark:border-zinc-900 bg-zinc-100 dark:bg-zinc-900/40 p-5">
        <div id="timeline-empty" class="text-center py-8 text-zinc-600 dark:text-zinc-400">
            <p class="text-sm">No execution logs recorded yet</p>
        </div>
        <div id="timeline-content" class="hidden space-y-2">
            <!-- Timeline entries will be injected here -->
        </div>
    </div>
</section>
{% endblock content %}

{% block scripts %}
<script>
// Pass node data as JSON to avoid HTML entity escaping issues
const nodeData = {{ nodes_json | safe }};
const graphData = {{ graph_data | json_encode | safe }};
// Action logs keyed by action_id (UUID string)
const actionLogs = {{ action_logs_json | safe }};

function payloadHasException(payloadText) {
  if (!payloadText) return false;
  try {
    const parsed = JSON.parse(payloadText);
    if (parsed && typeof parsed === 'object' && parsed.error) {
      return true;
    }
  } catch (_err) {
    // Fall back to a simple marker check for pretty-printed payloads.
    if (payloadText.includes('"__exception__"')) {
      return true;
    }
  }
  return false;
}

function deriveNodeStatus(node) {
  if (!node) return 'pending';
  if (node.status === 'failed' || node.status === 'exhausted' || node.status === 'timed_out') {
    return 'failed';
  }
  if (node.last_error) {
    return 'failed';
  }
  if (payloadHasException(node.response_payload)) {
    return 'failed';
  }
  return node.status || 'pending';
}

/**
 * DAGLayout - Reusable class for rendering DAG visualizations
 * Supports both horizontal and vertical orientations
 */
class DAGLayout {
  constructor(container, options = {}) {
    this.container = container;
    this.options = {
      orientation: options.orientation || 'horizontal', // 'horizontal' or 'vertical'
      minNodeWidth: options.minNodeWidth || 120,
      maxNodeWidth: options.maxNodeWidth || 280,
      nodeHeight: options.nodeHeight || 64,
      padding: options.padding || 24,
      gap: options.gap || 80,
      rowGap: options.rowGap || 80,
      onNodeClick: options.onNodeClick || null,
      isDark: document.documentElement.classList.contains('dark'),
    };
    this.positions = new Map();
    this.nodeElements = new Map();
    this.nodeWidths = new Map();
  }

  // Measure text width to determine node width
  measureNodeWidth(node) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    // Measure each text element
    ctx.font = '600 14px system-ui, sans-serif'; // semibold for action name
    const actionWidth = ctx.measureText(node.action).width;

    ctx.font = '500 10px ui-monospace, monospace'; // mono for node id
    const idWidth = ctx.measureText(node.id).width;

    ctx.font = '400 10px system-ui, sans-serif'; // normal for module
    const moduleWidth = ctx.measureText(node.module).width;

    // Take the max width + padding
    const textWidth = Math.max(actionWidth, idWidth, moduleWidth);
    const paddedWidth = textWidth + 32; // 16px padding on each side

    return Math.max(this.options.minNodeWidth, Math.min(paddedWidth, this.options.maxNodeWidth));
  }

  // Status colors for nodes (opaque backgrounds)
  getStatusColors(status) {
    const isDark = document.documentElement.classList.contains('dark');
    const colors = {
      'completed': {
        bg: isDark ? '#064e3b' : '#d1fae5',
        border: '#10b981',
        text: isDark ? '#6ee7b7' : '#059669',
        label: isDark ? '#a7f3d0' : '#047857'
      },
      'failed': {
        bg: isDark ? '#7f1d1d' : '#fee2e2',
        border: '#ef4444',
        text: isDark ? '#fca5a5' : '#dc2626',
        label: isDark ? '#fecaca' : '#b91c1c'
      },
      'dispatched': {
        bg: isDark ? '#78350f' : '#fef3c7',
        border: '#f59e0b',
        text: isDark ? '#fcd34d' : '#d97706',
        label: isDark ? '#fde68a' : '#b45309'
      },
      'pending': {
        bg: isDark ? '#27272a' : '#f4f4f5',
        border: isDark ? '#52525b' : '#a1a1aa',
        text: isDark ? '#a1a1aa' : '#71717a',
        label: isDark ? '#d4d4d8' : '#52525b'
      },
      'queued': {
        bg: isDark ? '#27272a' : '#f4f4f5',
        border: isDark ? '#52525b' : '#a1a1aa',
        text: isDark ? '#a1a1aa' : '#71717a',
        label: isDark ? '#d4d4d8' : '#52525b'
      }
    };
    return colors[status] || colors['pending'];
  }

  render(nodes) {
    if (!nodes || !nodes.length) return;

    this.container.innerHTML = '';

    const nodeMap = new Map(nodes.map(n => [n.id, n]));
    const depthCache = new Map();

    // Pre-calculate all node widths
    nodes.forEach(node => {
      this.nodeWidths.set(node.id, this.measureNodeWidth(node));
    });

    const computeDepth = (nodeId, stack = new Set()) => {
      if (depthCache.has(nodeId)) return depthCache.get(nodeId);
      const node = nodeMap.get(nodeId);
      if (!node || !node.depends_on || !node.depends_on.length) {
        depthCache.set(nodeId, 0);
        return 0;
      }
      if (stack.has(nodeId)) return 0;
      stack.add(nodeId);
      let depth = 0;
      node.depends_on.forEach(dep => {
        depth = Math.max(depth, computeDepth(dep, stack) + 1);
      });
      stack.delete(nodeId);
      depthCache.set(nodeId, depth);
      return depth;
    };

    const levels = [];
    nodes.forEach(node => {
      const depth = computeDepth(node.id);
      if (!levels[depth]) levels[depth] = [];
      levels[depth].push(node);
    });

    // Sort nodes within each level by ID for stable layout across refreshes
    levels.forEach(level => {
      if (level) level.sort((a, b) => a.id.localeCompare(b.id));
    });

    const normalizedLevels = Array.from({ length: levels.length }, (_, i) => levels[i] || []);
    const { nodeHeight, padding, gap, rowGap, orientation } = this.options;

    // Calculate max width per level
    const levelMaxWidths = normalizedLevels.map(levelNodes =>
      Math.max(...levelNodes.map(n => this.nodeWidths.get(n.id)), this.options.minNodeWidth)
    );

    // Calculate total dimensions
    const maxDepth = normalizedLevels.length;
    const maxNodesInLevel = Math.max(...normalizedLevels.map(l => l.length), 1);

    let totalWidth, totalHeight;
    if (orientation === 'vertical') {
      const maxLevelWidth = Math.max(...normalizedLevels.map(levelNodes =>
        levelNodes.reduce((sum, n) => sum + this.nodeWidths.get(n.id), 0) + (levelNodes.length - 1) * (rowGap / 2)
      ), 0);
      totalWidth = padding * 2 + maxLevelWidth;
      totalHeight = padding * 2 + maxDepth * gap + nodeHeight;
    } else {
      const levelWidthsSum = levelMaxWidths.reduce((sum, w) => sum + w, 0);
      totalWidth = padding * 2 + levelWidthsSum + (maxDepth - 1) * gap;
      totalHeight = padding * 2 + maxNodesInLevel * rowGap + nodeHeight;
    }

    // Create wrapper that defines the full scrollable area
    const wrapper = document.createElement('div');
    wrapper.style.cssText = `position: relative; width: ${totalWidth}px; height: ${Math.max(totalHeight, 300)}px;`;
    this.container.appendChild(wrapper);

    // Create SVG sized to full content
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.style.cssText = 'position: absolute; top: 0; left: 0; pointer-events: none;';
    svg.setAttribute('width', totalWidth);
    svg.setAttribute('height', Math.max(totalHeight, 300));
    wrapper.appendChild(svg);

    // Calculate cumulative positions for horizontal layout
    const levelStartX = [];
    let cumX = padding;
    levelMaxWidths.forEach((w, i) => {
      levelStartX[i] = cumX;
      cumX += w + gap;
    });

    // Create node elements
    normalizedLevels.forEach((levelNodes, depth) => {
      levelNodes.forEach((node, index) => {
        const nodeWidth = this.nodeWidths.get(node.id);
        const levelMaxWidth = levelMaxWidths[depth];

        let left, top;
        if (orientation === 'vertical') {
          // Center nodes within level for vertical orientation
          const levelTotalWidth = levelNodes.reduce((sum, n, i) =>
            sum + this.nodeWidths.get(n.id) + (i > 0 ? rowGap / 2 : 0), 0);
          let runningX = padding + (totalWidth - padding * 2 - levelTotalWidth) / 2;
          for (let i = 0; i < index; i++) {
            runningX += this.nodeWidths.get(levelNodes[i].id) + rowGap / 2;
          }
          left = runningX;
          top = padding + depth * gap;
        } else {
          left = levelStartX[depth] + (levelMaxWidth - nodeWidth) / 2;
          top = padding + index * rowGap;
        }

        this.positions.set(node.id, {
          x: left + nodeWidth / 2,
          y: top + nodeHeight / 2,
          left, top,
          width: nodeWidth
        });

        const el = this.createNodeElement(node, left, top, nodeWidth);
        wrapper.appendChild(el);
        this.nodeElements.set(node.id, el);
      });
    });

    // Draw edges
    const isDark = document.documentElement.classList.contains('dark');
    const strokeColor = isDark ? '#52525b' : '#d4d4d8';

    nodes.forEach(node => {
      if (!node.depends_on) return;
      node.depends_on.forEach(depId => {
        const start = this.positions.get(depId);
        const end = this.positions.get(node.id);
        if (!start || !end) return;

        const startWidth = start.width || this.options.minNodeWidth;
        const endWidth = end.width || this.options.minNodeWidth;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        let d;
        if (orientation === 'vertical') {
          const midY = (start.y + end.y) / 2;
          d = `M${start.x},${start.y + nodeHeight/2} C${start.x},${midY} ${end.x},${midY} ${end.x},${end.y - nodeHeight/2}`;
        } else {
          const midX = (start.x + end.x) / 2;
          d = `M${start.x + startWidth/2},${start.y} C${midX},${start.y} ${midX},${end.y} ${end.x - endWidth/2},${end.y}`;
        }
        path.setAttribute('d', d);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', strokeColor);
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-linecap', 'round');
        svg.appendChild(path);
      });
    });
  }

  createNodeElement(node, left, top, nodeWidth) {
    const { nodeHeight } = this.options;
    const colors = this.getStatusColors(node.status);

    const el = document.createElement('div');
    el.className = 'absolute rounded-xl px-3 py-2 cursor-pointer transition-all duration-150 hover:scale-[1.02] hover:shadow-lg';
    el.style.cssText = `
      left: ${left}px;
      top: ${top}px;
      width: ${nodeWidth}px;
      min-height: ${nodeHeight}px;
      background: ${colors.bg};
      border: 2px solid ${colors.border};
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      overflow: hidden;
    `;
    el.dataset.nodeId = node.id;

    el.innerHTML = `
      <p class="text-[10px] font-mono font-medium uppercase tracking-wider truncate" style="color: ${colors.label}">${node.id}</p>
      <p class="text-sm font-semibold truncate mt-0.5" style="color: ${colors.text}">${node.action}</p>
      <p class="text-[10px] truncate opacity-70" style="color: ${colors.text}">${node.module}</p>
    `;

    if (this.options.onNodeClick) {
      el.addEventListener('click', () => this.options.onNodeClick(node.id));
    }

    return el;
  }

  selectNode(nodeId) {
    // Clear previous selection
    this.nodeElements.forEach(el => {
      el.classList.remove('ring-2', 'ring-indigo-500', 'ring-offset-2');
    });

    // Highlight selected node
    const el = this.nodeElements.get(nodeId);
    if (el) {
      el.classList.add('ring-2', 'ring-indigo-500', 'ring-offset-2');
    }
  }
}

document.addEventListener('DOMContentLoaded', () => {
  const container = document.getElementById('execution-graph');
  if (!container) return;

  // Build node lookup from nodeData for payloads
  const nodeLookup = {};
  nodeData.forEach(n => {
    nodeLookup[n.id] = n;
  });

  // Merge status info from graphData into nodes for the DAG
  const nodes = graphData?.nodes || [];
  nodes.forEach(n => {
    if (nodeLookup[n.id]) {
      const detailedNode = nodeLookup[n.id];
      n.module = detailedNode.module;
      n.action = detailedNode.action;
      n.status = deriveNodeStatus(detailedNode);
    }
  });

  if (!nodes.length) return;

  // Remove empty placeholder
  const placeholder = document.getElementById('graph-empty');
  if (placeholder) placeholder.remove();

  // Create vertical DAG layout
  const dag = new DAGLayout(container, {
    orientation: 'vertical',
    minNodeWidth: 120,
    maxNodeWidth: 280,
    nodeHeight: 64,
    padding: 24,
    gap: 100,
    rowGap: 40,
    onNodeClick: selectNode
  });

  dag.render(nodes);

  // Node selection handling
  let selectedNodeId = null;

  function selectNode(nodeId) {
    selectedNodeId = nodeId;
    dag.selectNode(nodeId);

    const node = nodeLookup[nodeId];
    if (!node) return;

    // Update detail panel
    const placeholder = document.getElementById('detail-placeholder');
    const content = document.getElementById('detail-content');

    placeholder.classList.add('hidden');
    content.classList.remove('hidden');

    document.getElementById('detail-node-id').textContent = node.id;
    document.getElementById('detail-action-info').textContent = `${node.action} (${node.module})`;

    const statusEl = document.getElementById('detail-status');
    statusEl.textContent = node.status;
    statusEl.className = 'rounded-full px-3 py-1 text-xs font-semibold uppercase tracking-wide';

    const isDark = document.documentElement.classList.contains('dark');
    if (node.status === 'completed') {
      statusEl.classList.add(isDark ? 'bg-emerald-900/50' : 'bg-emerald-100', isDark ? 'text-emerald-400' : 'text-emerald-700');
    } else if (node.status === 'failed') {
      statusEl.classList.add(isDark ? 'bg-red-900/50' : 'bg-red-100', isDark ? 'text-red-400' : 'text-red-700');
    } else if (node.status === 'dispatched') {
      statusEl.classList.add(isDark ? 'bg-amber-900/50' : 'bg-amber-100', isDark ? 'text-amber-400' : 'text-amber-700');
    } else {
      statusEl.classList.add(isDark ? 'bg-zinc-800' : 'bg-zinc-200', isDark ? 'text-zinc-400' : 'text-zinc-600');
    }

    // Display payloads directly (no HTML entity issues since it's JSON)
    document.getElementById('detail-request').textContent = node.request_payload || '{}';
    document.getElementById('detail-response').textContent = node.response_payload || '{}';

    // Update error info section
    const errorInfoEl = document.getElementById('detail-error-info');
    const errorMessageEl = document.getElementById('detail-error-message');

    if (node.last_error) {
      errorInfoEl.classList.remove('hidden');
      errorMessageEl.textContent = node.last_error;
    } else {
      errorInfoEl.classList.add('hidden');
    }

    // Update retry info section
    const retryInfoEl = document.getElementById('detail-retry-info');
    const scheduledRowEl = document.getElementById('detail-scheduled-row');
    const maxRetries = node.retry_kind === 'timeout' ? node.timeout_retry_limit : node.max_retries;

    // Show retry info if there have been retries or action is queued/failed with scheduled time
    const showRetryInfo = node.attempt_number > 0 ||
                          (node.status === 'queued' && node.scheduled_at) ||
                          node.status === 'failed';

    if (showRetryInfo) {
      retryInfoEl.classList.remove('hidden');
      document.getElementById('detail-attempts').textContent = `${node.attempt_number + 1} / ${maxRetries + 1}`;
      document.getElementById('detail-max-retries').textContent = maxRetries;

      // Show scheduled_at if present and action is queued
      if (node.scheduled_at && node.status === 'queued') {
        scheduledRowEl.classList.remove('hidden');
        document.getElementById('detail-scheduled-at').textContent = node.scheduled_at;
      } else {
        scheduledRowEl.classList.add('hidden');
      }
    } else {
      retryInfoEl.classList.add('hidden');
    }

    // Update execution history section
    const historyEl = document.getElementById('detail-history');
    const historyContentEl = document.getElementById('detail-history-content');
    const logs = actionLogs[node.action_id] || [];

    if (logs.length > 0) {
      historyEl.classList.remove('hidden');
      historyContentEl.innerHTML = '';

      logs.forEach((log, idx) => {
        const row = document.createElement('div');
        row.className = 'rounded-lg p-2 text-xs ' + (isDark ? 'bg-zinc-800' : 'bg-zinc-200/70');

        // Status indicator
        let statusColor, statusText;
        if (log.success === true) {
          statusColor = isDark ? 'text-emerald-400' : 'text-emerald-600';
          statusText = 'Success';
        } else if (log.success === false) {
          statusColor = isDark ? 'text-red-400' : 'text-red-600';
          statusText = 'Failed';
        } else {
          statusColor = isDark ? 'text-amber-400' : 'text-amber-600';
          statusText = 'Running';
        }

        // Duration display
        let durationText = '-';
        if (log.duration_ms !== null && log.duration_ms !== undefined) {
          if (log.duration_ms < 1000) {
            durationText = log.duration_ms + 'ms';
          } else {
            durationText = (log.duration_ms / 1000).toFixed(2) + 's';
          }
        }

        row.innerHTML = `
          <div class="flex items-center justify-between gap-2">
            <span class="font-semibold ${isDark ? 'text-zinc-200' : 'text-zinc-800'}">Attempt ${log.attempt_number + 1}</span>
            <span class="font-semibold ${statusColor}">${statusText}</span>
          </div>
          <div class="mt-1 grid grid-cols-2 gap-x-4 ${isDark ? 'text-zinc-400' : 'text-zinc-600'}">
            <div>Started: <span class="${isDark ? 'text-zinc-300' : 'text-zinc-700'}">${log.dispatched_at}</span></div>
            <div>Duration: <span class="${isDark ? 'text-zinc-300' : 'text-zinc-700'}">${durationText}</span></div>
          </div>
          ${log.error_message ? `<div class="mt-1 text-red-500 dark:text-red-400 truncate" title="${log.error_message}">${log.error_message}</div>` : ''}
        `;

        historyContentEl.appendChild(row);
      });
    } else {
      historyEl.classList.add('hidden');
    }
  }

  // Select first node by default
  if (nodes.length > 0) {
    selectNode(nodes[0].id);
  }

  // Render the full execution timeline
  renderTimeline();
});

function renderTimeline() {
  const timelineEmpty = document.getElementById('timeline-empty');
  const timelineContent = document.getElementById('timeline-content');
  if (!timelineEmpty || !timelineContent) return;

  // Build action_id -> action info lookup from nodeData
  const actionInfoLookup = {};
  nodeData.forEach(n => {
    actionInfoLookup[n.action_id] = {
      nodeId: n.id,
      action: n.action,
      module: n.module
    };
  });

  // Flatten all logs from actionLogs (keyed by action_id) into a single array
  const allLogs = [];
  for (const [actionId, logs] of Object.entries(actionLogs)) {
    const info = actionInfoLookup[actionId] || { nodeId: actionId, action: 'Unknown', module: '' };
    logs.forEach(log => {
      allLogs.push({
        ...log,
        nodeId: info.nodeId,
        actionName: info.action,
        moduleName: info.module
      });
    });
  }

  // Sort by dispatched_at chronologically, with id as tiebreaker for stable ordering
  allLogs.sort((a, b) => {
    const dateA = new Date(a.dispatched_at);
    const dateB = new Date(b.dispatched_at);
    if (dateA - dateB !== 0) {
      return dateA - dateB;
    }
    // Use id as tiebreaker for consistent ordering when timestamps match
    return a.id.localeCompare(b.id);
  });

  if (allLogs.length === 0) {
    timelineEmpty.classList.remove('hidden');
    timelineContent.classList.add('hidden');
    return;
  }

  timelineEmpty.classList.add('hidden');
  timelineContent.classList.remove('hidden');
  timelineContent.innerHTML = '';

  const isDark = document.documentElement.classList.contains('dark');

  allLogs.forEach((log, idx) => {
    const row = document.createElement('div');
    row.className = 'rounded-lg ' + (isDark ? 'bg-zinc-800/50' : 'bg-zinc-200/50') + ' transition-colors overflow-hidden';

    // Status indicator
    let statusColor, statusBg, statusText;
    if (log.success === true) {
      statusColor = isDark ? 'text-emerald-400' : 'text-emerald-600';
      statusBg = isDark ? 'bg-emerald-900/50' : 'bg-emerald-100';
      statusText = 'Success';
    } else if (log.success === false) {
      statusColor = isDark ? 'text-red-400' : 'text-red-600';
      statusBg = isDark ? 'bg-red-900/50' : 'bg-red-100';
      statusText = 'Failed';
    } else {
      statusColor = isDark ? 'text-amber-400' : 'text-amber-600';
      statusBg = isDark ? 'bg-amber-900/50' : 'bg-amber-100';
      statusText = 'Running';
    }

    // Duration display
    let durationText = '-';
    if (log.duration_ms !== null && log.duration_ms !== undefined) {
      if (log.duration_ms < 1000) {
        durationText = log.duration_ms + 'ms';
      } else {
        durationText = (log.duration_ms / 1000).toFixed(2) + 's';
      }
    }

    // Timeline dot and line
    const isLast = idx === allLogs.length - 1;

    // Check if there's content to show (result_payload or error_message)
    const hasDetails = log.result_payload || log.error_message;
    const expandId = `timeline-expand-${idx}`;

    row.innerHTML = `
      <div class="flex items-start gap-4 p-3 ${hasDetails ? 'cursor-pointer hover:' + (isDark ? 'bg-zinc-800' : 'bg-zinc-200') : ''}" ${hasDetails ? `onclick="toggleTimelineExpand('${expandId}')"` : ''}>
        <div class="flex flex-col items-center pt-1">
          <div class="w-3 h-3 rounded-full ${statusBg} border-2 ${log.success === true ? 'border-emerald-500' : log.success === false ? 'border-red-500' : 'border-amber-500'}"></div>
          ${!isLast ? `<div class="w-0.5 h-full min-h-[24px] mt-1 ${isDark ? 'bg-zinc-700' : 'bg-zinc-300'}"></div>` : ''}
        </div>
        <div class="flex-1 min-w-0">
          <div class="flex items-center justify-between gap-2 mb-1">
            <div class="flex items-center gap-2 min-w-0">
              <span class="font-semibold ${isDark ? 'text-zinc-200' : 'text-zinc-800'} truncate">${log.actionName}</span>
              <span class="text-xs ${isDark ? 'text-zinc-500' : 'text-zinc-500'} font-mono">${log.moduleName}</span>
              <span class="text-xs px-1.5 py-0.5 rounded ${statusBg} ${statusColor} font-medium">${statusText}</span>
            </div>
            <div class="flex items-center gap-2">
              <span class="text-xs ${isDark ? 'text-zinc-500' : 'text-zinc-500'} whitespace-nowrap">Attempt ${log.attempt_number + 1}</span>
              ${hasDetails ? `<svg class="w-4 h-4 ${isDark ? 'text-zinc-500' : 'text-zinc-400'} transition-transform" id="${expandId}-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg>` : ''}
            </div>
          </div>
          <div class="flex items-center gap-4 text-xs ${isDark ? 'text-zinc-400' : 'text-zinc-600'}">
            <span>Started: <span class="${isDark ? 'text-zinc-300' : 'text-zinc-700'}">${log.dispatched_at}</span></span>
            <span>Duration: <span class="${isDark ? 'text-zinc-300' : 'text-zinc-700'}">${durationText}</span></span>
          </div>
          ${log.error_message && !log.result_payload ? `<div class="mt-1 text-xs text-red-500 dark:text-red-400 truncate" title="${escapeHtml(log.error_message)}">${escapeHtml(log.error_message)}</div>` : ''}
        </div>
      </div>
      ${hasDetails ? `
      <div id="${expandId}" class="hidden border-t ${isDark ? 'border-zinc-700' : 'border-zinc-300'} px-3 py-3 ml-7">
        ${log.error_message ? `
        <div class="mb-3">
          <p class="text-xs uppercase tracking-[0.4em] text-red-500 dark:text-red-400 mb-1">Error</p>
          <pre class="text-xs ${isDark ? 'text-red-300 bg-red-900/20' : 'text-red-700 bg-red-100'} p-2 rounded-lg whitespace-pre-wrap break-words font-mono overflow-x-auto max-h-32">${escapeHtml(log.error_message)}</pre>
        </div>
        ` : ''}
        ${log.result_payload ? `
        <div>
          <p class="text-xs uppercase tracking-[0.4em] ${isDark ? 'text-zinc-500' : 'text-zinc-500'} mb-1">${log.success === false ? 'Exception' : 'Result'}</p>
          <pre class="text-xs ${isDark ? 'text-zinc-300 bg-zinc-900/70' : 'text-zinc-700 bg-zinc-100'} p-2 rounded-lg whitespace-pre-wrap break-words font-mono overflow-x-auto max-h-64">${escapeHtml(log.result_payload)}</pre>
        </div>
        ` : ''}
      </div>
      ` : ''}
    `;

    timelineContent.appendChild(row);
  });
}

function toggleTimelineExpand(id) {
  const content = document.getElementById(id);
  const icon = document.getElementById(id + '-icon');
  if (content) {
    content.classList.toggle('hidden');
    if (icon) {
      icon.classList.toggle('rotate-180');
    }
  }
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}
</script>
{% endblock scripts %}
