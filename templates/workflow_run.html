{% extends "base.html" %}
{% import "macros.html" as macros %}

{% block title %}{{ title }}{% endblock title %}

{% block content %}
<section class="space-y-4">
    <a href="/workflow/{{ workflow.id }}" class="text-xs uppercase tracking-[0.4em] text-zinc-500 transition hover:text-zinc-700 dark:hover:text-zinc-300">&larr; Back to workflow detail</a>
    <div class="space-y-2">
        <h1 class="text-3xl font-semibold tracking-tight text-zinc-900 dark:text-white">Run {{ instance.id }}</h1>
        <p class="text-sm text-zinc-600 dark:text-zinc-400">{{ workflow.name }}</p>
    </div>
    <dl class="grid gap-4 rounded-2xl border border-zinc-200 dark:border-zinc-900 bg-zinc-100 dark:bg-zinc-900/40 p-6 md:grid-cols-2 lg:grid-cols-4">
        <div>
            <dt class="text-xs uppercase tracking-[0.4em] text-zinc-500">Version ID</dt>
            <dd class="text-lg font-semibold text-zinc-900 dark:text-white font-mono text-sm">{{ workflow.id }}</dd>
        </div>
        <div>
            <dt class="text-xs uppercase tracking-[0.4em] text-zinc-500">Run Created</dt>
            <dd class="text-lg font-semibold text-zinc-900 dark:text-white">{{ macros::datetime(timestamp=instance.created_at) }}</dd>
        </div>
        <div>
            <dt class="text-xs uppercase tracking-[0.4em] text-zinc-500">Status</dt>
            <dd class="text-lg font-semibold text-zinc-900 dark:text-white">{{ instance.status }}</dd>
        </div>
        <div>
            <dt class="text-xs uppercase tracking-[0.4em] text-zinc-500">Progress</dt>
            <dd class="text-lg font-semibold text-zinc-900 dark:text-white">{{ instance.progress }}</dd>
        </div>
    </dl>
</section>

<section class="grid gap-6 lg:grid-cols-2">
    <div class="rounded-2xl border border-zinc-200 dark:border-zinc-900 bg-zinc-100 dark:bg-zinc-900/40 p-5">
        <p class="text-xs uppercase tracking-[0.4em] text-zinc-500">Input Payload</p>
        <pre class="mt-3 overflow-x-auto whitespace-pre-wrap rounded-xl bg-zinc-200/70 dark:bg-zinc-950/70 p-4 text-xs text-zinc-800 dark:text-zinc-200">{{ instance.input_payload }}</pre>
    </div>
    <div class="rounded-2xl border border-zinc-200 dark:border-zinc-900 bg-zinc-100 dark:bg-zinc-900/40 p-5">
        <p class="text-xs uppercase tracking-[0.4em] text-zinc-500">Result Payload</p>
        <pre class="mt-3 overflow-x-auto whitespace-pre-wrap rounded-xl bg-zinc-200/70 dark:bg-zinc-950/70 p-4 text-xs text-zinc-800 dark:text-zinc-200">{{ instance.result_payload }}</pre>
    </div>
</section>

<section class="space-y-3">
    <div>
        <p class="text-xs uppercase tracking-[0.4em] text-zinc-500">Execution</p>
        <h2 class="text-2xl font-semibold text-zinc-900 dark:text-white">Execution Details</h2>
        <p class="text-sm text-zinc-600 dark:text-zinc-400">Click a node in the graph to view details</p>
    </div>
    <div class="grid gap-6 lg:grid-cols-2">
        <!-- Vertical DAG (left side) -->
        <div id="execution-graph" class="relative min-h-[400px] max-h-[600px] overflow-auto rounded-2xl border border-zinc-200 dark:border-zinc-900 bg-gradient-to-b from-zinc-50 to-zinc-100 dark:from-zinc-950 dark:to-zinc-900 p-4">
            <p id="graph-empty" class="p-6 text-sm text-zinc-600 dark:text-zinc-400">No DAG nodes to display.</p>
        </div>

        <!-- Detail panel (right side) -->
        <div id="detail-panel" class="rounded-2xl border border-zinc-200 dark:border-zinc-900 bg-zinc-100 dark:bg-zinc-900/40 p-5 lg:sticky lg:top-6 lg:self-start max-h-[600px] overflow-auto">
            <div id="detail-placeholder" class="text-center py-12 text-zinc-600 dark:text-zinc-400">
                <svg class="mx-auto h-12 w-12 text-zinc-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122m-5.657 5.656l-2.12 2.122" />
                </svg>
                <p class="mt-4 text-sm">Select a node to view details</p>
            </div>
            <div id="detail-content" class="hidden space-y-4">
                <div class="flex items-center justify-between gap-2">
                    <div>
                        <p id="detail-node-id" class="text-lg font-semibold text-zinc-900 dark:text-white"></p>
                        <p id="detail-action-info" class="text-sm text-zinc-700 dark:text-zinc-300"></p>
                    </div>
                    <span id="detail-status" class="rounded-full px-3 py-1 text-xs font-semibold uppercase tracking-wide"></span>
                </div>
                <!-- Retry info section (shown when relevant) -->
                <div id="detail-retry-info" class="hidden rounded-xl bg-amber-100/50 dark:bg-amber-900/20 border border-amber-300 dark:border-amber-700 p-3">
                    <p class="text-xs uppercase tracking-[0.4em] text-amber-700 dark:text-amber-400 mb-2">Retry Status</p>
                    <div class="grid grid-cols-2 gap-2 text-sm">
                        <div>
                            <span class="text-zinc-600 dark:text-zinc-400">Attempts:</span>
                            <span id="detail-attempts" class="font-semibold text-zinc-900 dark:text-white"></span>
                        </div>
                        <div>
                            <span class="text-zinc-600 dark:text-zinc-400">Max Retries:</span>
                            <span id="detail-max-retries" class="font-semibold text-zinc-900 dark:text-white"></span>
                        </div>
                    </div>
                    <div id="detail-scheduled-row" class="mt-2 hidden">
                        <span class="text-zinc-600 dark:text-zinc-400 text-sm">Scheduled At:</span>
                        <span id="detail-scheduled-at" class="font-semibold text-zinc-900 dark:text-white text-sm"></span>
                    </div>
                </div>
                <div>
                    <p class="text-xs uppercase tracking-[0.4em] text-zinc-500">Request</p>
                    <pre id="detail-request" class="mt-2 max-h-64 overflow-auto whitespace-pre-wrap rounded-xl bg-zinc-200/70 dark:bg-zinc-950/70 p-3 text-xs text-zinc-800 dark:text-zinc-200 font-mono"></pre>
                </div>
                <div>
                    <p class="text-xs uppercase tracking-[0.4em] text-zinc-500">Response</p>
                    <pre id="detail-response" class="mt-2 max-h-64 overflow-auto whitespace-pre-wrap rounded-xl bg-zinc-200/70 dark:bg-zinc-950/70 p-3 text-xs text-zinc-800 dark:text-zinc-200 font-mono"></pre>
                </div>
            </div>
        </div>
    </div>
</section>
{% endblock content %}

{% block scripts %}
<script>
// Pass node data as JSON to avoid HTML entity escaping issues
const nodeData = {{ nodes_json | safe }};
const graphData = {{ graph_data | json_encode | safe }};

/**
 * DAGLayout - Reusable class for rendering DAG visualizations
 * Supports both horizontal and vertical orientations
 */
class DAGLayout {
  constructor(container, options = {}) {
    this.container = container;
    this.options = {
      orientation: options.orientation || 'horizontal', // 'horizontal' or 'vertical'
      minNodeWidth: options.minNodeWidth || 120,
      maxNodeWidth: options.maxNodeWidth || 280,
      nodeHeight: options.nodeHeight || 64,
      padding: options.padding || 24,
      gap: options.gap || 80,
      rowGap: options.rowGap || 80,
      onNodeClick: options.onNodeClick || null,
      isDark: document.documentElement.classList.contains('dark'),
    };
    this.positions = new Map();
    this.nodeElements = new Map();
    this.nodeWidths = new Map();
  }

  // Measure text width to determine node width
  measureNodeWidth(node) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    // Measure each text element
    ctx.font = '600 14px system-ui, sans-serif'; // semibold for action name
    const actionWidth = ctx.measureText(node.action).width;

    ctx.font = '500 10px ui-monospace, monospace'; // mono for node id
    const idWidth = ctx.measureText(node.id).width;

    ctx.font = '400 10px system-ui, sans-serif'; // normal for module
    const moduleWidth = ctx.measureText(node.module).width;

    // Take the max width + padding
    const textWidth = Math.max(actionWidth, idWidth, moduleWidth);
    const paddedWidth = textWidth + 32; // 16px padding on each side

    return Math.max(this.options.minNodeWidth, Math.min(paddedWidth, this.options.maxNodeWidth));
  }

  // Status colors for nodes (opaque backgrounds)
  getStatusColors(status) {
    const isDark = document.documentElement.classList.contains('dark');
    const colors = {
      'completed': {
        bg: isDark ? '#064e3b' : '#d1fae5',
        border: '#10b981',
        text: isDark ? '#6ee7b7' : '#059669',
        label: isDark ? '#a7f3d0' : '#047857'
      },
      'failed': {
        bg: isDark ? '#7f1d1d' : '#fee2e2',
        border: '#ef4444',
        text: isDark ? '#fca5a5' : '#dc2626',
        label: isDark ? '#fecaca' : '#b91c1c'
      },
      'dispatched': {
        bg: isDark ? '#78350f' : '#fef3c7',
        border: '#f59e0b',
        text: isDark ? '#fcd34d' : '#d97706',
        label: isDark ? '#fde68a' : '#b45309'
      },
      'pending': {
        bg: isDark ? '#27272a' : '#f4f4f5',
        border: isDark ? '#52525b' : '#a1a1aa',
        text: isDark ? '#a1a1aa' : '#71717a',
        label: isDark ? '#d4d4d8' : '#52525b'
      },
      'queued': {
        bg: isDark ? '#27272a' : '#f4f4f5',
        border: isDark ? '#52525b' : '#a1a1aa',
        text: isDark ? '#a1a1aa' : '#71717a',
        label: isDark ? '#d4d4d8' : '#52525b'
      }
    };
    return colors[status] || colors['pending'];
  }

  render(nodes) {
    if (!nodes || !nodes.length) return;

    this.container.innerHTML = '';

    const nodeMap = new Map(nodes.map(n => [n.id, n]));
    const depthCache = new Map();

    // Pre-calculate all node widths
    nodes.forEach(node => {
      this.nodeWidths.set(node.id, this.measureNodeWidth(node));
    });

    const computeDepth = (nodeId, stack = new Set()) => {
      if (depthCache.has(nodeId)) return depthCache.get(nodeId);
      const node = nodeMap.get(nodeId);
      if (!node || !node.depends_on || !node.depends_on.length) {
        depthCache.set(nodeId, 0);
        return 0;
      }
      if (stack.has(nodeId)) return 0;
      stack.add(nodeId);
      let depth = 0;
      node.depends_on.forEach(dep => {
        depth = Math.max(depth, computeDepth(dep, stack) + 1);
      });
      stack.delete(nodeId);
      depthCache.set(nodeId, depth);
      return depth;
    };

    const levels = [];
    nodes.forEach(node => {
      const depth = computeDepth(node.id);
      if (!levels[depth]) levels[depth] = [];
      levels[depth].push(node);
    });

    const normalizedLevels = Array.from({ length: levels.length }, (_, i) => levels[i] || []);
    const { nodeHeight, padding, gap, rowGap, orientation } = this.options;

    // Calculate max width per level
    const levelMaxWidths = normalizedLevels.map(levelNodes =>
      Math.max(...levelNodes.map(n => this.nodeWidths.get(n.id)), this.options.minNodeWidth)
    );

    // Calculate total dimensions
    const maxDepth = normalizedLevels.length;
    const maxNodesInLevel = Math.max(...normalizedLevels.map(l => l.length), 1);

    let totalWidth, totalHeight;
    if (orientation === 'vertical') {
      const maxLevelWidth = Math.max(...normalizedLevels.map(levelNodes =>
        levelNodes.reduce((sum, n) => sum + this.nodeWidths.get(n.id), 0) + (levelNodes.length - 1) * (rowGap / 2)
      ), 0);
      totalWidth = padding * 2 + maxLevelWidth;
      totalHeight = padding * 2 + maxDepth * gap + nodeHeight;
    } else {
      const levelWidthsSum = levelMaxWidths.reduce((sum, w) => sum + w, 0);
      totalWidth = padding * 2 + levelWidthsSum + (maxDepth - 1) * gap;
      totalHeight = padding * 2 + maxNodesInLevel * rowGap + nodeHeight;
    }

    // Create wrapper that defines the full scrollable area
    const wrapper = document.createElement('div');
    wrapper.style.cssText = `position: relative; width: ${totalWidth}px; height: ${Math.max(totalHeight, 300)}px;`;
    this.container.appendChild(wrapper);

    // Create SVG sized to full content
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.style.cssText = 'position: absolute; top: 0; left: 0; pointer-events: none;';
    svg.setAttribute('width', totalWidth);
    svg.setAttribute('height', Math.max(totalHeight, 300));
    wrapper.appendChild(svg);

    // Calculate cumulative positions for horizontal layout
    const levelStartX = [];
    let cumX = padding;
    levelMaxWidths.forEach((w, i) => {
      levelStartX[i] = cumX;
      cumX += w + gap;
    });

    // Create node elements
    normalizedLevels.forEach((levelNodes, depth) => {
      levelNodes.forEach((node, index) => {
        const nodeWidth = this.nodeWidths.get(node.id);
        const levelMaxWidth = levelMaxWidths[depth];

        let left, top;
        if (orientation === 'vertical') {
          // Center nodes within level for vertical orientation
          const levelTotalWidth = levelNodes.reduce((sum, n, i) =>
            sum + this.nodeWidths.get(n.id) + (i > 0 ? rowGap / 2 : 0), 0);
          let runningX = padding + (totalWidth - padding * 2 - levelTotalWidth) / 2;
          for (let i = 0; i < index; i++) {
            runningX += this.nodeWidths.get(levelNodes[i].id) + rowGap / 2;
          }
          left = runningX;
          top = padding + depth * gap;
        } else {
          left = levelStartX[depth] + (levelMaxWidth - nodeWidth) / 2;
          top = padding + index * rowGap;
        }

        this.positions.set(node.id, {
          x: left + nodeWidth / 2,
          y: top + nodeHeight / 2,
          left, top,
          width: nodeWidth
        });

        const el = this.createNodeElement(node, left, top, nodeWidth);
        wrapper.appendChild(el);
        this.nodeElements.set(node.id, el);
      });
    });

    // Draw edges
    const isDark = document.documentElement.classList.contains('dark');
    const strokeColor = isDark ? '#52525b' : '#d4d4d8';

    nodes.forEach(node => {
      if (!node.depends_on) return;
      node.depends_on.forEach(depId => {
        const start = this.positions.get(depId);
        const end = this.positions.get(node.id);
        if (!start || !end) return;

        const startWidth = start.width || this.options.minNodeWidth;
        const endWidth = end.width || this.options.minNodeWidth;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        let d;
        if (orientation === 'vertical') {
          const midY = (start.y + end.y) / 2;
          d = `M${start.x},${start.y + nodeHeight/2} C${start.x},${midY} ${end.x},${midY} ${end.x},${end.y - nodeHeight/2}`;
        } else {
          const midX = (start.x + end.x) / 2;
          d = `M${start.x + startWidth/2},${start.y} C${midX},${start.y} ${midX},${end.y} ${end.x - endWidth/2},${end.y}`;
        }
        path.setAttribute('d', d);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', strokeColor);
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-linecap', 'round');
        svg.appendChild(path);
      });
    });
  }

  createNodeElement(node, left, top, nodeWidth) {
    const { nodeHeight } = this.options;
    const colors = this.getStatusColors(node.status);

    const el = document.createElement('div');
    el.className = 'absolute rounded-xl px-3 py-2 cursor-pointer transition-all duration-150 hover:scale-[1.02] hover:shadow-lg';
    el.style.cssText = `
      left: ${left}px;
      top: ${top}px;
      width: ${nodeWidth}px;
      min-height: ${nodeHeight}px;
      background: ${colors.bg};
      border: 2px solid ${colors.border};
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      overflow: hidden;
    `;
    el.dataset.nodeId = node.id;

    el.innerHTML = `
      <p class="text-[10px] font-mono font-medium uppercase tracking-wider truncate" style="color: ${colors.label}">${node.id}</p>
      <p class="text-sm font-semibold truncate mt-0.5" style="color: ${colors.text}">${node.action}</p>
      <p class="text-[10px] truncate opacity-70" style="color: ${colors.text}">${node.module}</p>
    `;

    if (this.options.onNodeClick) {
      el.addEventListener('click', () => this.options.onNodeClick(node.id));
    }

    return el;
  }

  selectNode(nodeId) {
    // Clear previous selection
    this.nodeElements.forEach(el => {
      el.classList.remove('ring-2', 'ring-indigo-500', 'ring-offset-2');
    });

    // Highlight selected node
    const el = this.nodeElements.get(nodeId);
    if (el) {
      el.classList.add('ring-2', 'ring-indigo-500', 'ring-offset-2');
    }
  }
}

document.addEventListener('DOMContentLoaded', () => {
  const container = document.getElementById('execution-graph');
  if (!container) return;

  // Build node lookup from nodeData for payloads
  const nodeLookup = {};
  nodeData.forEach(n => {
    nodeLookup[n.id] = n;
  });

  // Merge status info from graphData into nodes for the DAG
  const nodes = graphData?.nodes || [];
  nodes.forEach(n => {
    if (nodeLookup[n.id]) {
      n.module = nodeLookup[n.id].module;
      n.action = nodeLookup[n.id].action;
    }
  });

  if (!nodes.length) return;

  // Remove empty placeholder
  const placeholder = document.getElementById('graph-empty');
  if (placeholder) placeholder.remove();

  // Create vertical DAG layout
  const dag = new DAGLayout(container, {
    orientation: 'vertical',
    minNodeWidth: 120,
    maxNodeWidth: 280,
    nodeHeight: 64,
    padding: 24,
    gap: 100,
    rowGap: 40,
    onNodeClick: selectNode
  });

  dag.render(nodes);

  // Node selection handling
  let selectedNodeId = null;

  function selectNode(nodeId) {
    selectedNodeId = nodeId;
    dag.selectNode(nodeId);

    const node = nodeLookup[nodeId];
    if (!node) return;

    // Update detail panel
    const placeholder = document.getElementById('detail-placeholder');
    const content = document.getElementById('detail-content');

    placeholder.classList.add('hidden');
    content.classList.remove('hidden');

    document.getElementById('detail-node-id').textContent = node.id;
    document.getElementById('detail-action-info').textContent = `${node.action} (${node.module})`;

    const statusEl = document.getElementById('detail-status');
    statusEl.textContent = node.status;
    statusEl.className = 'rounded-full px-3 py-1 text-xs font-semibold uppercase tracking-wide';

    const isDark = document.documentElement.classList.contains('dark');
    if (node.status === 'completed') {
      statusEl.classList.add(isDark ? 'bg-emerald-900/50' : 'bg-emerald-100', isDark ? 'text-emerald-400' : 'text-emerald-700');
    } else if (node.status === 'failed') {
      statusEl.classList.add(isDark ? 'bg-red-900/50' : 'bg-red-100', isDark ? 'text-red-400' : 'text-red-700');
    } else if (node.status === 'dispatched') {
      statusEl.classList.add(isDark ? 'bg-amber-900/50' : 'bg-amber-100', isDark ? 'text-amber-400' : 'text-amber-700');
    } else {
      statusEl.classList.add(isDark ? 'bg-zinc-800' : 'bg-zinc-200', isDark ? 'text-zinc-400' : 'text-zinc-600');
    }

    // Display payloads directly (no HTML entity issues since it's JSON)
    document.getElementById('detail-request').textContent = node.request_payload || '{}';
    document.getElementById('detail-response').textContent = node.response_payload || '{}';

    // Update retry info section
    const retryInfoEl = document.getElementById('detail-retry-info');
    const scheduledRowEl = document.getElementById('detail-scheduled-row');
    const maxRetries = node.retry_kind === 'timeout' ? node.timeout_retry_limit : node.max_retries;

    // Show retry info if there have been retries or action is queued/failed with scheduled time
    const showRetryInfo = node.attempt_number > 0 ||
                          (node.status === 'queued' && node.scheduled_at) ||
                          node.status === 'failed';

    if (showRetryInfo) {
      retryInfoEl.classList.remove('hidden');
      document.getElementById('detail-attempts').textContent = `${node.attempt_number + 1} / ${maxRetries + 1}`;
      document.getElementById('detail-max-retries').textContent = maxRetries;

      // Show scheduled_at if present and action is queued
      if (node.scheduled_at && node.status === 'queued') {
        scheduledRowEl.classList.remove('hidden');
        document.getElementById('detail-scheduled-at').textContent = node.scheduled_at;
      } else {
        scheduledRowEl.classList.add('hidden');
      }
    } else {
      retryInfoEl.classList.add('hidden');
    }
  }

  // Select first node by default
  if (nodes.length > 0) {
    selectNode(nodes[0].id);
  }
});
</script>
{% endblock scripts %}
