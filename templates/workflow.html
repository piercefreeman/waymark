{% extends "base.html" %}
{% import "macros.html" as macros %}

{% block title %}{{ title }}{% endblock title %}

{% block content %}
<section class="space-y-4">
    <a href="/workflows" class="text-xs uppercase tracking-[0.4em] text-zinc-500 transition hover:text-zinc-700 dark:hover:text-zinc-300">&larr; Back to all workflows</a>
    <div class="flex items-start justify-between gap-4">
        <div class="space-y-2">
            <h1 class="text-3xl font-semibold tracking-tight text-zinc-900 dark:text-white">{{ workflow.name }}</h1>
            <p class="text-sm text-zinc-600 dark:text-zinc-400">Workflow version #{{ workflow.id }}</p>
        </div>
        <form method="POST" action="/workflows/{{ workflow.id }}/delete" class="shrink-0" onsubmit="return confirm('Are you sure you want to delete this workflow version? This will force a re-registration of the IR on next run. This action cannot be undone.');">
            <button type="submit" class="rounded-lg bg-red-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-red-500">
                Delete Version
            </button>
        </form>
    </div>
    <dl class="grid gap-4 rounded-2xl border border-zinc-200 dark:border-zinc-900 bg-zinc-100 dark:bg-zinc-900/40 p-6 sm:grid-cols-2">
        <div>
            <dt class="text-xs uppercase tracking-[0.4em] text-zinc-500">Version ID</dt>
            <dd class="text-lg font-semibold text-zinc-900 dark:text-white">{{ workflow.id }}</dd>
        </div>
        <div>
            <dt class="text-xs uppercase tracking-[0.4em] text-zinc-500">Created</dt>
            <dd class="text-lg font-semibold text-zinc-900 dark:text-white">{{ macros::datetime(timestamp=workflow.created_at) }}</dd>
        </div>
        <div>
            <dt class="text-xs uppercase tracking-[0.4em] text-zinc-500">Hash</dt>
            <dd class="font-mono text-sm text-zinc-800 dark:text-zinc-200 break-all">{{ workflow.hash }}</dd>
        </div>
        <div>
            <dt class="text-xs uppercase tracking-[0.4em] text-zinc-500">Execution</dt>
            <dd class="text-lg font-semibold text-zinc-900 dark:text-white">{{ workflow.concurrency_label }}</dd>
        </div>
    </dl>
</section>

<section class="rounded-2xl border border-zinc-200 dark:border-zinc-900 bg-zinc-100 dark:bg-zinc-900/40 p-5">
    <p class="text-xs uppercase tracking-[0.4em] text-zinc-500">Workflow IR</p>
    <pre class="mt-3 max-h-[420px] overflow-auto whitespace-pre-wrap rounded-xl bg-zinc-200/70 dark:bg-zinc-950/70 p-4 text-xs text-zinc-800 dark:text-zinc-200 font-mono">{{ ir_text }}</pre>
</section>

<section class="space-y-3">
    <div>
        <p class="text-xs uppercase tracking-[0.4em] text-zinc-500">Visualization</p>
        <h2 class="text-2xl font-semibold text-zinc-900 dark:text-white">DAG Layout</h2>
    </div>
    <div id="workflow-graph" class="relative min-h-[280px] max-h-[500px] overflow-auto rounded-2xl border border-zinc-200 dark:border-zinc-900 bg-gradient-to-br from-zinc-100 to-white dark:from-zinc-950 dark:to-zinc-900">
        <p id="graph-empty" class="p-6 text-sm text-zinc-600 dark:text-zinc-400">Workflow nodes will draw here once a DAG is registered.</p>
    </div>
</section>

<section class="space-y-3">
    <div>
        <p class="text-xs uppercase tracking-[0.4em] text-zinc-500">Recent Runs</p>
        <h2 class="text-2xl font-semibold text-zinc-900 dark:text-white">Latest Workflow Instances</h2>
    </div>
    {% if has_runs %}
        <div class="rounded-2xl border border-zinc-200 dark:border-zinc-900 bg-white dark:bg-zinc-900/40 overflow-hidden">
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-zinc-200 dark:divide-zinc-800 text-sm">
                    <thead class="bg-zinc-100 dark:bg-zinc-800/60">
                        <tr>
                            <th class="px-4 py-3 text-left text-xs uppercase tracking-wider font-semibold text-zinc-500 dark:text-zinc-400">Instance</th>
                            <th class="px-4 py-3 text-left text-xs uppercase tracking-wider font-semibold text-zinc-500 dark:text-zinc-400">Created</th>
                            <th class="px-4 py-3 text-left text-xs uppercase tracking-wider font-semibold text-zinc-500 dark:text-zinc-400">Status</th>
                            <th class="px-4 py-3 text-left text-xs uppercase tracking-wider font-semibold text-zinc-500 dark:text-zinc-400">Progress</th>
                            <th class="px-4 py-3"></th>
                        </tr>
                    </thead>
                    <tbody class="divide-y divide-zinc-200 dark:divide-zinc-800">
                        {% for run in recent_runs %}
                            <tr>
                                <td class="px-4 py-3 font-mono text-xs text-zinc-700 dark:text-zinc-300">{{ run.id }}</td>
                                <td class="px-4 py-3 text-zinc-700 dark:text-zinc-300">{{ macros::datetime(timestamp=run.created_at) }}</td>
                                <td class="px-4 py-3">{{ macros::status_badge(status=run.status) }}</td>
                                <td class="px-4 py-3 text-zinc-700 dark:text-zinc-300">{{ run.progress }}</td>
                                <td class="px-4 py-3 text-right">
                                    <a href="{{ run.url }}" class="text-sm font-semibold text-indigo-600 dark:text-indigo-400 transition hover:text-indigo-500 dark:hover:text-indigo-300">View &rarr;</a>
                                </td>
                            </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        </div>
    {% else %}
        <div class="rounded-2xl border border-dashed border-zinc-300 dark:border-zinc-800 bg-zinc-100 dark:bg-zinc-900/40 p-6 text-sm text-zinc-600 dark:text-zinc-400">
            No workflow runs recorded yet.
        </div>
    {% endif %}
</section>

{% endblock content %}

{% block scripts %}
<script>
const graphData = {{ graph_data | json_encode | safe }};

/**
 * DAGLayout - Reusable class for rendering DAG visualizations
 * Supports both horizontal and vertical orientations
 */
class DAGLayout {
  constructor(container, options = {}) {
    this.container = container;
    this.options = {
      orientation: options.orientation || 'horizontal',
      minNodeWidth: options.minNodeWidth || 120,
      maxNodeWidth: options.maxNodeWidth || 300,
      nodeHeight: options.nodeHeight || 72,
      padding: options.padding || 32,
      gap: options.gap || 80,
      rowGap: options.rowGap || 100,
      onNodeClick: options.onNodeClick || null,
    };
    this.positions = new Map();
    this.nodeElements = new Map();
    this.nodeWidths = new Map();
  }

  // Measure text width to determine node width
  measureNodeWidth(node) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    // Measure each text element
    ctx.font = '600 14px system-ui, sans-serif'; // semibold for action name
    const actionWidth = ctx.measureText(node.action).width;

    ctx.font = '500 10px ui-monospace, monospace'; // mono for node id
    const idWidth = ctx.measureText(node.id).width;

    ctx.font = '400 12px system-ui, sans-serif'; // normal for module
    const moduleWidth = ctx.measureText(node.module).width;

    // Take the max width + padding
    const textWidth = Math.max(actionWidth, idWidth, moduleWidth);
    const paddedWidth = textWidth + 40; // 20px padding on each side

    return Math.max(this.options.minNodeWidth, Math.min(paddedWidth, this.options.maxNodeWidth));
  }

  render(nodes) {
    if (!nodes || !nodes.length) return;

    this.container.innerHTML = '';

    const nodeMap = new Map(nodes.map(n => [n.id, n]));
    const depthCache = new Map();

    // Pre-calculate all node widths
    nodes.forEach(node => {
      this.nodeWidths.set(node.id, this.measureNodeWidth(node));
    });

    const computeDepth = (nodeId, stack = new Set()) => {
      if (depthCache.has(nodeId)) return depthCache.get(nodeId);
      const node = nodeMap.get(nodeId);
      if (!node || !node.depends_on || !node.depends_on.length) {
        depthCache.set(nodeId, 0);
        return 0;
      }
      if (stack.has(nodeId)) return 0;
      stack.add(nodeId);
      let depth = 0;
      node.depends_on.forEach(dep => {
        depth = Math.max(depth, computeDepth(dep, stack) + 1);
      });
      stack.delete(nodeId);
      depthCache.set(nodeId, depth);
      return depth;
    };

    const levels = [];
    nodes.forEach(node => {
      const depth = computeDepth(node.id);
      if (!levels[depth]) levels[depth] = [];
      levels[depth].push(node);
    });

    // Sort nodes within each level by ID for stable layout across refreshes
    levels.forEach(level => {
      if (level) level.sort((a, b) => a.id.localeCompare(b.id));
    });

    const normalizedLevels = Array.from({ length: levels.length }, (_, i) => levels[i] || []);
    const { nodeHeight, padding, gap, rowGap, orientation } = this.options;

    // Calculate max width per level for horizontal layout
    const levelMaxWidths = normalizedLevels.map(levelNodes =>
      Math.max(...levelNodes.map(n => this.nodeWidths.get(n.id)), this.options.minNodeWidth)
    );

    // Calculate total dimensions
    const maxDepth = normalizedLevels.length;
    const maxNodesInLevel = Math.max(...normalizedLevels.map(l => l.length), 1);

    let totalWidth, totalHeight;
    if (orientation === 'vertical') {
      const maxLevelWidth = Math.max(...normalizedLevels.map(levelNodes =>
        levelNodes.reduce((sum, n) => sum + this.nodeWidths.get(n.id), 0) + (levelNodes.length - 1) * (rowGap / 2)
      ), 0);
      totalWidth = padding * 2 + maxLevelWidth;
      totalHeight = padding * 2 + maxDepth * gap + nodeHeight;
    } else {
      // Sum of all level widths + gaps between levels
      const levelWidthsSum = levelMaxWidths.reduce((sum, w) => sum + w, 0);
      totalWidth = padding * 2 + levelWidthsSum + (maxDepth - 1) * gap;
      totalHeight = padding * 2 + maxNodesInLevel * rowGap + nodeHeight;
    }

    // Create wrapper that defines the full scrollable area
    const wrapper = document.createElement('div');
    wrapper.style.cssText = `position: relative; width: ${totalWidth}px; height: ${Math.max(totalHeight, 240)}px;`;
    this.container.appendChild(wrapper);

    // Create SVG sized to full content
    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.style.cssText = 'position: absolute; top: 0; left: 0; pointer-events: none;';
    svg.setAttribute('width', totalWidth);
    svg.setAttribute('height', Math.max(totalHeight, 240));
    wrapper.appendChild(svg);

    // Calculate cumulative x positions for each level (horizontal layout)
    const levelStartX = [];
    let cumX = padding;
    levelMaxWidths.forEach((w, i) => {
      levelStartX[i] = cumX;
      cumX += w + gap;
    });

    // Create node elements
    normalizedLevels.forEach((levelNodes, depth) => {
      levelNodes.forEach((node, index) => {
        const nodeWidth = this.nodeWidths.get(node.id);
        const levelMaxWidth = levelMaxWidths[depth];

        let left, top;
        if (orientation === 'vertical') {
          // Center nodes within level for vertical orientation
          const levelTotalWidth = levelNodes.reduce((sum, n, i) =>
            sum + this.nodeWidths.get(n.id) + (i > 0 ? rowGap / 2 : 0), 0);
          let runningX = padding + (totalWidth - padding * 2 - levelTotalWidth) / 2;
          for (let i = 0; i < index; i++) {
            runningX += this.nodeWidths.get(levelNodes[i].id) + rowGap / 2;
          }
          left = runningX;
          top = padding + depth * gap;
        } else {
          // Center each node within its level's max width column
          left = levelStartX[depth] + (levelMaxWidth - nodeWidth) / 2;
          top = padding + index * rowGap;
        }

        this.positions.set(node.id, {
          x: left + nodeWidth / 2,
          y: top + nodeHeight / 2,
          left, top,
          width: nodeWidth
        });

        const el = this.createNodeElement(node, left, top, nodeWidth);
        wrapper.appendChild(el);
        this.nodeElements.set(node.id, el);
      });
    });

    // Draw edges
    const isDark = document.documentElement.classList.contains('dark');
    const strokeColor = isDark ? '#52525b' : '#d4d4d8';

    nodes.forEach(node => {
      if (!node.depends_on) return;
      node.depends_on.forEach(depId => {
        const start = this.positions.get(depId);
        const end = this.positions.get(node.id);
        if (!start || !end) return;

        const startWidth = start.width || this.options.minNodeWidth;
        const endWidth = end.width || this.options.minNodeWidth;

        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        let d;
        if (orientation === 'vertical') {
          const midY = (start.y + end.y) / 2;
          d = `M${start.x},${start.y + nodeHeight/2} C${start.x},${midY} ${end.x},${midY} ${end.x},${end.y - nodeHeight/2}`;
        } else {
          const midX = (start.x + end.x) / 2;
          d = `M${start.x + startWidth/2},${start.y} C${midX},${start.y} ${midX},${end.y} ${end.x - endWidth/2},${end.y}`;
        }
        path.setAttribute('d', d);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', strokeColor);
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-linecap', 'round');
        svg.appendChild(path);
      });
    });
  }

  createNodeElement(node, left, top, nodeWidth) {
    const { nodeHeight } = this.options;
    const isDark = document.documentElement.classList.contains('dark');

    const el = document.createElement('div');
    el.className = 'absolute rounded-xl px-4 py-3 transition-all duration-150';
    el.style.cssText = `
      left: ${left}px;
      top: ${top}px;
      width: ${nodeWidth}px;
      min-height: ${nodeHeight}px;
      background: ${isDark ? '#27272a' : '#ffffff'};
      border: 2px solid ${isDark ? '#3f3f46' : '#d4d4d8'};
      box-shadow: 0 4px 12px rgba(0,0,0,${isDark ? '0.3' : '0.08'});
      overflow: hidden;
    `;
    el.dataset.nodeId = node.id;

    el.innerHTML = `
      <p class="text-[10px] font-mono font-medium uppercase tracking-wider truncate ${isDark ? 'text-zinc-500' : 'text-zinc-400'}">${node.id}</p>
      <p class="text-sm font-semibold mt-1 truncate ${isDark ? 'text-white' : 'text-zinc-900'}">${node.action}</p>
      <p class="text-xs truncate ${isDark ? 'text-zinc-400' : 'text-zinc-600'}">${node.module}</p>
    `;

    if (this.options.onNodeClick) {
      el.classList.add('cursor-pointer', 'hover:scale-[1.02]', 'hover:shadow-lg');
      el.addEventListener('click', () => this.options.onNodeClick(node.id));
    }

    return el;
  }
}

document.addEventListener('DOMContentLoaded', () => {
  if (!graphData || !graphData.nodes || !graphData.nodes.length) return;

  const placeholder = document.getElementById('graph-empty');
  if (placeholder) placeholder.remove();

  const container = document.getElementById('workflow-graph');
  if (!container) return;

  const dag = new DAGLayout(container, {
    orientation: 'horizontal',
    minNodeWidth: 120,
    maxNodeWidth: 300,
    nodeHeight: 72,
    padding: 32,
    gap: 80,
    rowGap: 100
  });

  dag.render(graphData.nodes);
});
</script>
{% endblock scripts %}
